(:module ("RAM" [("Data" "Variant") ("Addr" "Variant") ("WE" "Bit") ("ClkG" "Bit") ("Go" "Bit") ("Wait" "Bit")] [("O" "Variant") ("Done" "Bit") ("Busy" "Bit")] {"TreeGroup" "CoreLib\\\\Memory"}) [(:input "Data" "Variant" nil (17 19) {}) (:input "Addr" "Variant" "A" (17 26) {}) (:input "WE" "Bit" "B" (17 46) {}) (:input "ClkG" "Bit" "C" (17 50) {}) (:input "Go" "Bit" "D" (17 54) {}) (:input "Wait" "Bit" "E" (162 62) {}) (:output "O" "Variant" nil (166 22) {}) (:output "Done" "Bit" "A" (166 35) {}) (:output "Busy" "Bit" "B" (18 64) {}) (:symbol "RAMSP" nil [("Data" "Variant") ("Addr" "Variant") ("ClkG" "Bit") ("WE" "Bit")] [("Data" "Variant")] (135 19) {}) (:symbol "RegOnGo" nil [("D" "Variant") ("ClkG" "Bit") ("AClr" "Bit") ("Go" "Bit") ("Wait" "Bit")] [("Q" "Variant") ("ClkG" "Bit") ("AClr" "Bit") ("Done" "Bit") ("Busy" "Bit")] (59 24) {}) (:symbol "AND" nil [("In1" "Bit") ("In2" "Bit")] [("Out" "Bit")] (47 32) {}) (:symbol "Mux" nil [("A" "Variant") ("B" "Variant") ("S" "Bit")] [("O" "Variant")] (80 21) {}) (:symbol "INVERT" nil [("In1" "Bit")] [("Out" "Bit")] (35 31) {}) (:symbol "AND" "A" [("In1" "Variant") ("In2" "Variant") ("In3" "Variant")] [("Out1" "Variant")] (117 25) {}) (:symbol "INVERT" "A" [("In1" "Bit")] [("Out" "Bit")] (105 24) {}) (:junction "Variant" nil (55 26)) (:junction "Bit" "A" (77 38)) (:junction "Bit" "B" (34 54)) (:junction "Bit" "C" (30 46)) (:junction "Bit" "D" (26 50)) (:junction "Bit" "E" (57 58)) (:net ("RAMSP" nil 0) ("Output" nil 0) []) (:net ("RegOnGo" nil 3) ("Output" "A" 0) []) (:net ("Junction" "E" 0) ("Output" "B" 0) [(16 58)]) (:net ("Input" nil 0) ("RAMSP" nil 0) [(131 19) (131 21)]) (:net ("Mux" nil 0) ("RAMSP" nil 1) []) (:net ("Junction" "D" 1) ("RAMSP" nil 2) [(133 50) (133 27)]) (:net ("AND" "A" 0) ("RAMSP" nil 3) [(130 28) (130 30)]) (:net ("Junction" nil 1) ("RegOnGo" nil 0) []) (:net ("Junction" "D" 0) ("RegOnGo" nil 1) [(26 29)]) (:net ("AND" nil 0) ("RegOnGo" nil 3) []) (:net ("Junction" "A" 0) ("RegOnGo" nil 4) []) (:net ("INVERT" nil 0) ("AND" nil 0) []) (:net ("Junction" "B" 0) ("AND" nil 1) [(34 37)]) (:net ("Junction" nil 0) ("Mux" nil 0) [(55 23)]) (:net ("RegOnGo" nil 0) ("Mux" nil 1) []) (:net ("Junction" "A" 1) ("Mux" nil 2) [(77 29)]) (:net ("Input" "A" 0) ("Junction" nil 0) []) (:net ("Junction" "C" 0) ("INVERT" nil 0) [(30 34)]) (:net ("Input" "E" 0) ("Junction" "A" 0) [(164 38)]) (:net ("INVERT" "A" 0) ("AND" "A" 0) []) (:net ("Junction" "C" 1) ("AND" "A" 1) [(108 46) (108 30)]) (:net ("Junction" "B" 1) ("AND" "A" 2) [(112 54) (112 33)]) (:net ("Junction" "E" 1) ("INVERT" "A" 0) [(102 58) (102 27)]) (:net ("Input" "D" 0) ("Junction" "B" 0) []) (:net ("Input" "B" 0) ("Junction" "C" 0) []) (:net ("Input" "C" 0) ("Junction" "D" 0) []) (:net ("RegOnGo" nil 4) ("Junction" "E" 0) [(57 38)]) (:text "Register the Address \non a Read to be used \nif a Wait comes on." (50 9)) (:text "If waiting, then switch the RAM's \naddress to the stored address, \nso if a read  Done is pending, we \nwill continue reading from the \nsame address." (75 3)) (:text "Only write when Go, \nWE and not Busy." (107 12)) (:text "A Wait will keep a \nRead or a Write from \nstarting, but only a \nRead from completing." (146 66)) (:text "Dones only come \nout after a Read." (160 27)) (:text "Reads and writes \nare synchronous." (132 10)) (:text "Don't need to store the \nGo on a write because \nwe don't need to send \nout a Done on a write." (38 61)) (:text "The Mux won't effect writes (it \nwill be a passthrough) because \nwrites will only occur when we \nare not Busy which is the same \nas when we are not Waiting for \nthe RegOnGo object." (73 60)) (:text "O is valid while \nDone is high." (160 12))])
