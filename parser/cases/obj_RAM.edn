(:object (:proto "RAM" [("Variant" "Data") ("Variant" "Addr") ("Bit" "WE") ("Bit" "ClkG") ("Bit" "Go") ("Bit" "Wait")] [("Variant" "O") ("Bit" "Done") ("Bit" "Busy")] {:TreeGroup "CoreLib\\\\Memory"}) [(:input "Data" "Variant" nil (17 19) {}) (:input "Addr" "Variant" "A" (17 26) {}) (:input "WE" "Bit" "B" (17 46) {}) (:input "ClkG" "Bit" "C" (17 50) {}) (:input "Go" "Bit" "D" (17 54) {}) (:input "Wait" "Bit" "E" (162 62) {}) (:output "O" "Variant" nil (166 22) {}) (:output "Done" "Bit" "A" (166 35) {}) (:output "Busy" "Bit" "B" (18 64) {}) (:proto "RAMSP" [("Variant" "Data") ("Variant" "Addr") ("Bit" "ClkG") ("Bit" "WE")] [("Variant" "Data")] {:gui (135 19)}) (:proto "RegOnGo" [("Variant" "D") ("Bit" "ClkG") ("Bit" "AClr") ("Bit" "Go") ("Bit" "Wait")] [("Variant" "Q") ("Bit" "ClkG") ("Bit" "AClr") ("Bit" "Done") ("Bit" "Busy")] {:gui (59 24)}) (:proto "AND" [("Bit" "In1") ("Bit" "In2")] [("Bit" "Out")] {:gui (47 32)}) (:proto "Mux" [("Variant" "A") ("Variant" "B") ("Bit" "S")] [("Variant" "O")] {:gui (80 21)}) (:proto "INVERT" [("Bit" "In1")] [("Bit" "Out")] {:gui (35 31)}) (:proto "AND:A" [("Variant" "In1") ("Variant" "In2") ("Variant" "In3")] [("Variant" "Out1")] {:gui (117 25)}) (:proto "INVERT:A" [("Bit" "In1")] [("Bit" "Out")] {:gui (105 24)}) (:text (50 9) "Register the Address \non a Read to be used \nif a Wait comes on.") (:text (75 3) "If waiting, then switch the RAM's \naddress to the stored address, \nso if a read  Done is pending, we \nwill continue reading from the \nsame address.") (:text (107 12) "Only write when Go, \nWE and not Busy.") (:text (146 66) "A Wait will keep a \nRead or a Write from \nstarting, but only a \nRead from completing.") (:text (160 27) "Dones only come \nout after a Read.") (:text (132 10) "Reads and writes \nare synchronous.") (:text (38 61) "Don't need to store the \nGo on a write because \nwe don't need to send \nout a Done on a write.") (:text (73 60) "The Mux won't effect writes (it \nwill be a passthrough) because \nwrites will only occur when we \nare not Busy which is the same \nas when we are not Waiting for \nthe RegOnGo object.") (:text (160 12) "O is valid while \nDone is high.") (:proto "Junction" [("Variant" "In0")] [("Variant" "Out1") ("Variant" "Out2") ("Variant" "Out3")] {:gui (55 26)}) (:proto "Junction:A" [("Bit" "In2")] [("Bit" "Out1") ("Bit" "Out2") ("Bit" "Out3")] {:gui (77 38)}) (:proto "Junction:B" [("Bit" "In0")] [("Bit" "Out1") ("Bit" "Out2") ("Bit" "Out3")] {:gui (34 54)}) (:proto "Junction:C" [("Bit" "In0")] [("Bit" "Out1") ("Bit" "Out2") ("Bit" "Out3")] {:gui (30 46)}) (:proto "Junction:D" [("Bit" "In0")] [("Bit" "Out1") ("Bit" "Out2") ("Bit" "Out3")] {:gui (26 50)}) (:proto "Junction:E" [("Bit" "In1")] [("Bit" "Out1") ("Bit" "Out2") ("Bit" "Out3")] {:gui (57 58)}) (:net "Output.0" "RAMSP.0" [] {}) (:net "Output:A.0" "RegOnGo.3" [] {}) (:net "Output:B.0" "Junction:E.0" [(16 58)] {}) (:net "RAMSP.0" "Input.0" [(131 19) (131 21)] {}) (:net "RAMSP.1" "Mux.0" [] {}) (:net "RAMSP.2" "Junction:D.1" [(133 50) (133 27)] {}) (:net "RAMSP.3" "AND:A.0" [(130 28) (130 30)] {}) (:net "RegOnGo.0" "Junction.1" [] {}) (:net "RegOnGo.1" "Junction:D.0" [(26 29)] {}) (:net "RegOnGo.3" "AND.0" [] {}) (:net "RegOnGo.4" "Junction:A.0" [] {}) (:net "AND.0" "INVERT.0" [] {}) (:net "AND.1" "Junction:B.0" [(34 37)] {}) (:net "Mux.0" "Junction.0" [(55 23)] {}) (:net "Mux.1" "RegOnGo.0" [] {}) (:net "Mux.2" "Junction:A.1" [(77 29)] {}) (:net "Junction.0" "Input:A.0" [] {}) (:net "INVERT.0" "Junction:C.0" [(30 34)] {}) (:net "Junction:A.0" "Input:E.0" [(164 38)] {}) (:net "AND:A.0" "INVERT:A.0" [] {}) (:net "AND:A.1" "Junction:C.1" [(108 46) (108 30)] {}) (:net "AND:A.2" "Junction:B.1" [(112 54) (112 33)] {}) (:net "INVERT:A.0" "Junction:E.1" [(102 58) (102 27)] {}) (:net "Junction:B.0" "Input:D.0" [] {}) (:net "Junction:C.0" "Input:B.0" [] {}) (:net "Junction:D.0" "Input:C.0" [] {}) (:net "Junction:E.0" "RegOnGo.4" [(57 38)] {})])
