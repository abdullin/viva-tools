VIVA 2.33 Implementation Independent Algorithm Description Language
// Sheet   6/18/2004 4:02:11 PM


DataSet Fix32 = ( Word , Word ); //_Attributes 4,12632256,System\Static
DataSet Fix16 = ( Byte , Byte ); //_Attributes 4,32896,System\Static
DataSet "Byte*" = ( Pointer ); //_Attributes 1,11141375,System,16401
DataSet DeviceIOControlConstants = ( Word , Word ); //_Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet "DWord*" = ( Word , Word ); //_Attributes 1,11141375,System\Static,16403
DataSet DeviceAccessConstants = ( Word , Word ); //_Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet DeviceShareConstants = ( Word , Word ); //_Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet DeviceCreateConstants = ( Word , Word ); //_Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet DeviceAttributeConstants = ( Word , Word ); //_Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet "QWord*" = ( Word , Word ); //_Attributes 1,11141375,System\Static,16405
DataSet Complex = ( List ); //_Attributes 1,8421504
DataSet Fixed = ( List ); //_Attributes 1,4227327
DataSet Floating = ( List ); //_Attributes 1,32896
DataSet Signed = ( Variant ); //_Attributes 1,16776960
DataSet Pipelined = ( Bit ); //_Attributes 1,0
DataSet "IMemory*" = ( Word , Word ); //_Attributes 1,11141375,VIVASTANDARDOBJECTSLib,9
DataSet "Ix86Atoms*" = ( Word , Word ); //_Attributes 1,11141375,VIVAATOMLib,9
DataSet FileModeConstants = ( Word , Word ); //_Attributes 1,11141375,VIVASTANDARDOBJECTSLib,3
DataSet "IFileObject*" = ( Word , Word ); //_Attributes 1,11141375,VIVASTANDARDOBJECTSLib,9
DataSet "Variant*" = ( Pointer ); //_Attributes 1,11141375,System\$BIN
DataSet "ComUInt*" = ( Word , Word ); //_Attributes 1,11141375,System\Com
DataSet "MSB032*" = ( Word , Word ); //_Attributes 1,11141375,System\$MSB,16385
DataSet "ISBHC_LinkNV*" = ( Word , Word ); //_Attributes 1,11141375,SBHC_LinkLib,9
DataSet "BIN512*" = ( Word , Word ); //_Attributes 1,11141375,System\$BIN,16385
DataSet 8BitSigned = ( MSB009 ); //_Attributes 2,12632256,System
DataSet "MSB016*" = ( Word , Word ); //_Attributes 1,11141375,System\$MSB,16385

Object TestLib
//_Attributes WipSheet
{
 //_ Object Prototypes
 Object Text;  //_GUI 189,0,<TreeGroup>CoreLibArial,8,-2147483640,0
 Object Text;  //_GUI 3,6,Welcome to TestLibArial,20,8388608,1
 Object Text;  //_GUI 5,21,WarningArial,12,8421504,1
 Object Text;  //_GUI 3,12,.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .Arial,12,255,1
 Object Text;  //_GUI 100,16,............................................Arial,12,255,1
 Object Text;  //_GUI 9,57,Double-click the Tests box to view tests.Arial,8,255,1
 Object Text;  //_GUI 110,21,Testing ProcedureArial,12,8421504,1
 Object Text;  //_GUI 5,27,TestLib must be loaded with Corelib if you want anything to compile.Arial,9,0,0
 Object Text;  //_GUI 110,27,Each test needs to be recorded if bugs are found enter them into the bug database and note them appropriately.Definition - Bug: a difference between expected and actual outcome.The tests need to be performed with a variety of datasets to ensure proper functionality, for example…   Use a MSB05, MSB38, MSB110, MSB192, LSB05, LSB38…fixed, float…etc.  This will also identify which objects are missing overloads which we can add to future versions of CoreLibPlease note which datasets you use during your testing.Testing should be done on each PE to test System Descriptions and Behavioral Communications.Definition - Major Bug: GPFs, Access Violations, pieces of your computer hitting you in the face, etc. Testing for the school projects should also be done on each PE to ensure they will work with any of the PE's and system descriptions.Arial,9,0,0
 Object Tests;  //_GUI 23,46

 // Behavior Topology
}

Object Tests
//_Attributes TreeGroup=TestLib,Icon=Example
{
 //_ Object Prototypes
 Object Registers_Tests;  //_GUI 95,38
 Object Shifting_Tests;  //_GUI 75,38
 Object GrammaticalOps_Tests;  //_GUI 135,38
 Object Convert_Tests;  //_GUI 54,38
 Object Control_Tests;  //_GUI 32,38
 Object Arithmetic_Tests;  //_GUI 9,38
 Object Text;  //_GUI 51,4,CoreLib TestsArial,20,8388608,1
 Object Text;  //_GUI 43,14,Each object contains a library of tests. Double-click an object to see associated examples.Arial,12,255,1
 Object Memory_Tests;  //_GUI 116,38

 // Behavior Topology
}

Object Registers_Tests
//_Attributes TreeGroup=TestLib\Registers,Icon=Example
{
 //_ Object Prototypes
 Object Text;  //_GUI 50,19,To view and compile an test, double-click the preferred object from the options that follow.Arial,12,255,1
 Object Text;  //_GUI 58,3,Registers    TestsArial,20,8388608,1
 Object ( Variant Q, Bit Done, Bit Busy) Test_Register
    ( Variant D, Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 23,42

 // Behavior Topology
}

Object Shifting_Tests
//_Attributes TreeGroup=TestLib\Shifting,Icon=Example
{
 //_ Object Prototypes
 Object ( Variant MidData, Variant Out1, Bit MidBusy
    , Bit Busy) "P->S and S->P"( LSB016 Input, MSB004 S_Size, Bit Go
    , Bit Wait) ;  //_GUI 18,44
 Object ( Variant MidData, Bit Stobe, Bit Done
    , Bit Busy) "Test_P->S"( LSB016 Input, MSB004 S_Size, Bit Go
    , Bit Wait) ;  //_GUI 53,44
 Object ( Variant middat, Variant Data, Bit "S->P Busy"
    , Bit "P->S Done", Bit Done, Bit Busy) Test_Par_Ser( LSB064 Data
    , LSB008 S_Size, Bit ClkG, Bit I, Bit Wait) ;  //_GUI 86,43
 Object Text;  //_GUI 51,17,To view and compile an test, double-click the preferred object from the options that follow.Arial,12,255,1
 Object Text;  //_GUI 59,7,Shifting TestsArial,20,8388608,1

 // Behavior Topology
}

Object GrammaticalOps_Tests
//_Attributes TreeGroup=TestLib\GrammaticalOps,Icon=Example
{
 //_ Object Prototypes
 Object Text;  //_GUI 51,21,To view and compile an test, double-click the preferred object from the options that follow.Arial,12,255,1
 Object Text;  //_GUI 44,10,GrammaticalOps TestsArial,20,8388608,1
 Object ( Bit Bit, Bit Bit1, Bit Bit2) Test_get_LSB_bit
    ( Bit In1, Bit In2, LSB002 In3) ;  //_GUI 31,46

 // Behavior Topology
}

Object Convert_Tests
//_Attributes TreeGroup=TestLib\Convert,Icon=Example
{
 //_ Object Prototypes
 Object Text;  //_GUI 47,18,To view and compile an test, double-click the preferred object from the options that follow.Arial,12,255,1
 Object Text;  //_GUI 49,6,Convert TestsArial,20,8388608,1
 Object ( Variant P, Variant Q, Variant P1) Test_Context_on_list
    ( Fix32 A, LSB040 Binary) ;  //_GUI 11,47
 Object ( Variant Out1, Bit Busy) Test_convert_stalls( Float Data
    , Bit I, Bit Wait) ;  //_GUI 41,47
 Object ( Bit OFL_MSB032, Variant Q_MSB032, Bit "OFL_Signed(16)"
    , Variant "Q_Signed(16)", Bit "OFL_Fixed(8. 8)", Variant "Q_Fixed(8. 8)", Bit "OFL_Float(9 . 23)"
    , Variant "Q_Float(9 . 23)") "Test_Convert->Fixed(3,3)"( Fix32 "D_Fixed(16 . 16)", MSB032 D_MSB032, Int "D_Signed(16)"
    , Fix16 "D_Fixed(8. 8)", Float "D_Float(9 . 23)", Bit Go) ;  //_GUI 70,46
 Object ( Bit OFL_MSB032, Variant Q_MSB032, Bit "OFL_Signed(16)"
    , Variant "Q_Signed(16)", Bit "OFL_Fixed(16 . 16)", Variant "Q_Fixed(16 . 16)", Bit "OFL_Float(11 . 53)"
    , Variant "Q_Float(11. 53)") "Test_Convert->Floating(3,3)"( Float "D_Float(9 . 23)", MSB032 D_MSB032, Int "D_Signed(16)"
    , Fix32 "D_Fixed(16 . 16)", Double "D_Float(11. 53)", Bit Go) ;  //_GUI 109,45
 Object ( Bit OFL_MSB008, Variant Q_MSB008, Bit OFL_MSB032
    , Variant Q_MSB032, Bit "OFL_Signed(16)", Variant "Q_Signed(16)", Bit "OFL_Fixed(16 . 16)"
    , Variant "Q_Fixed(16 . 16)", Bit "OFL_Float(9 . 23)", Variant "Q_Float(9 . 23)") "Test_Convert->Num(3,3)"( MSB008 D_MSB008
    , MSB032 D_MSB032, Int "D_Signed(16)", Fix32 "D_Fixed(16 . 16)", Float "D_Float(9 . 23)"
    , Bit Go) ;  //_GUI 14,81
 Object ( Bit OFL_MSB032, Variant Q_MSB032, Bit "OFL_Signed(16)"
    , Variant "Q_Signed(16)", Bit "OFL_Fixed(16 . 16)", Variant "Q_Fixed(16 . 16)", Bit "OFL_Float(9 . 23)"
    , Variant "Q_Float(9 . 23)") "Test_Convert->Signed(3,3)"( Int "Signed(32)", MSB032 D_MSB032, Int "D_Signed(16)"
    , Fix32 "D_Fixed(16 . 16)", Float "D_Float(9 . 23)", Bit Go) ;  //_GUI 55,81
 Object ( Bit ClkG, Variant Q, Bit Done
    , Bit Busy) Test_StaticOut_Signed( Int A, Bit ClkG, Bit Go
    , Bit Wait) ;  //_GUI 96,80
 Object ( Variant Output, Variant Done, Bit Busy) Ex_ConvertGDBW
    ( MSB016 MSB016, Fix32 Fix32, Int Int, Float Float
    , Bit Go, Bit Wait) ;  //_GUI 130,79

 // Behavior Topology
}

Object Control_Tests
//_Attributes TreeGroup=TestLib\Control,Icon=Example
{
// Description:
// Control Objects test sheet
//
// Date:
// March 11, 2004
 //_ Object Prototypes
 Object Text;  //_GUI 47,18,To view and compile an test, double-click the preferred object from the options that follow.Arial,12,255,1
 Object Text;  //_GUI 54,7,Control TestsArial,20,8388608,1
 Object ( Variant Iteration, Variant Count, Variant Iteration1
    , Bit Wait, Bit Done) Test_DoneForN_Iterations( Bit ClkG, Bit I) ;  //_GUI 13,44
 Object ( Bit GoOne, Bit B, Bit Going
    , Bit D, Bit GoOne1, Bit B1, Bit Going1
    , Bit D1) Test_GDBW_Clr( Bit ClkG, Bit G, Bit W
    , Bit DoneIn, Bit AClr) ;  //_GUI 56,44
 Object ( Variant Busy1, Variant Busy2, Bit Done) Test_Sync
    ( Bit ClkG, Bit Go1, Bit Go2, Bit Wait) ;  //_GUI 99,43

 // Behavior Topology
}

Object Arithmetic_Tests
//_Attributes TreeGroup=TestLib\Arithmetic,Icon=Example
{
// Description:
// Arithmetic objects test sheet
//
// Date:
// March10, 2004
 //_ Object Prototypes
 Object Text;  //_GUI 55,18,To view and compile an test, double-click the preferred object from the options that follow.Arial,12,255,1
 Object Text;  //_GUI 60,7,Arithmetic TestsArial,20,8388608,1
 Object ( Variant Whole, Variant Fractional) Split_Fixed( Fix32 A) ;  //_GUI 25,39
 Object ( Variant Out1, Bit Done, Bit Busy) sum_products
    ( Bit I, Bit Wait) ;  //_GUI 49,38
 Object ( Variant Q, Bit Done, Bit Busy) sum_products_radix
    ( Bit I, Bit Wait) ;  //_GUI 76,38
 Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) test_add_gdbw_fixed( Fix32 A, Fix32 B
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 105,37
 Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) test_add_gdbw_float( Float A, Float B
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 22,61
 Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) test_add_gdbw_lsb( LSB008 A, Bit ClkG
    , Bit Go, Bit Wait) ;  //_GUI 48,61
 Object ( Variant Q, Variant R, Bit ClkG
    , Bit Done, Variant Busy) test_div_gdbw_fixed( Fix32 A, Fix32 B
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 77,61
 Object ( Variant Q, Variant R, Bit ClkG
    , Bit Done, Variant Busy) test_div_gdbw_float( Float A, Float B
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 106,61
 Object ( Variant Q, Variant R, Bit ClkG
    , Bit Done, Variant Busy) test_div_gdbw_var( Variant A, Variant B
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 21,89
 Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) test_mul_gdbw_fixed( Fix32 A, Fix32 B
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 110,89
 Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) test_mul_gdbw_float( Float A, Float B
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 20,116
 Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) test_mul_gdbw_var_bit( Variant A, Variant B
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 48,89
 Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) test_mul_gdbw_var_varrad( Variant A, Variant B
    , Variant Radix, Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 78,89
 Object ( Variant P, Bit Done, Variant Busy) test_sqrt_gdbw_fixed
    ( Fix32 A, Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 52,116
 Object ( Variant P, Bit Done, Variant Busy) test_sqrt_gdbw_float
    ( Float A, Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 82,116
 Object ( Variant P, Bit Done, Variant Busy) test_sqrt_gdbw_var
    ( LSB008 A, Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 111,116

 // Behavior Topology
}

Object Memory_Tests
//_Attributes TreeGroup=TestLib\Memory,Icon=Example
{
 //_ Object Prototypes
 Object Text;  //_GUI 49,20,To view and compile an test, double-click the preferred object from the options that follow.Arial,12,255,1
 Object Text;  //_GUI 54,8,Memory TestsArial,20,8388608,1

 // Behavior Topology
}

Object ( Variant Q, Bit Done, Bit Busy) Test_Register
    ( Variant D, Bit ClkG, Bit Go, Bit Wait) 
//_Attributes TreeGroup=TestLib\Registers
{
 //_ Object Prototypes
 Object ( Variant D) Input;  //_GUI 23,25
 Object ( Bit ClkG) Input:A;  //_GUI 22,28
 Object ( Bit Go) Input:B;  //_GUI 22,31
 Object ( Bit Wait) Input:C;  //_GUI 60,34
 Object Output( Variant Q) ;  //_GUI 64,25
 Object Output:A( Bit Done) ;  //_GUI 64,31
 Object Output:B( Bit Busy) ;  //_GUI 26,34
 Object ( Variant Q, Bit ClkG, Bit Done
    , Bit Busy) Register( Variant D, Bit ClkG, Bit Go
    , Bit Wait) ;  //_GUI 26,24
 //_Attributes Documentation=$Bit
 Object ( Variant Q, Bit ClkG, Bit Done
    , Bit Busy) Register:A( Variant D, Bit ClkG, Bit Go
    , Bit Wait) ;  //_GUI 53,24
 //_Attributes Documentation=$Bit

 // Behavior Topology
 Output = Register:A.Q;  
 Output:A = Register:A.Done;  
 Output:B = Register.Busy;  
 Register.D = Input;  
 Register.ClkG = Input:A;  
 Register.Go = Input:B;  
 Register.Wait = Register:A.Busy;  
 Register:A.D = Register.Q;  
 Register:A.ClkG = Register.ClkG;  
 Register:A.Go = Register.Done;  
 Register:A.Wait = Input:C;  
}

Object ( Variant MidData, Variant Out1, Bit MidBusy
    , Bit Busy) "P->S and S->P"( LSB016 Input, MSB004 S_Size, Bit Go
    , Bit Wait) 
//_Attributes TreeGroup=TestLib\Shifting
{
 //_ Object Prototypes
 Object ( LSB016 Input) Input;  //_GUI 19,28
 //_Attributes WidgetHex=True,WidgetWidth=164,WidgetHeight=49
 Object ( MSB004 S_Size) Input:A;  //_GUI 48,31
 Object ( Bit Go) Input:B;  //_GUI 20,36
 Object ( Bit Wait) Input:C;  //_GUI 140,46
 Object Output( Variant MidData) ;  //_GUI 81,21
 //_Attributes WidgetHex=True,WidgetWidth=104,WidgetHeight=49
 Object Output:A( Variant Out1) ;  //_GUI 153,32
 //_Attributes WidgetHex=True,WidgetWidth=164,WidgetHeight=49
 Object Output:B( Bit MidBusy) ;  //_GUI 80,48
 Object Output:C( Bit Busy) ;  //_GUI 57,69
 Object ( Variant Q) RegEn( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 131,30
 Object ( Variant Data, Variant P_Type, Bit Shift_Out
    , Bit Done, Bit Busy) "Parallel->Serial"( Variant Data, Variant S_Size
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 57,27
 Object ( Bit Pulse) OneShot( Bit I, Bit ClkG) ;  //_GUI 33,35
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In2) ;  //_GUI 79,40
 Object ( Variant Q, Bit Done, Bit Busy) "Serial->Parallel"
    ( Variant Data, Variant P_Type, Bit ClkG, Bit Go
    , Bit Wait) ;  //_GUI 90,27
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 80,28

 // Behavior Topology
 Output = Junction:A.Out1;  
 Output:A = RegEn;  
 Output:B = Junction.Out3;  
 Output:C = "Parallel->Serial".Busy;  //_GUI 52,70, 52,41
 RegEn.D = "Serial->Parallel".Q;  //_GUI 129,32, 129,30
 RegEn.EN = "Serial->Parallel".Done;  
 "Parallel->Serial".Data = Input;  
 "Parallel->Serial".S_Size = Input:A;  
 "Parallel->Serial".Go = OneShot;  
 "Parallel->Serial".Wait = Junction.Out1;  
 OneShot.I = Input:B;  
 Junction = "Serial->Parallel".Busy;  
 "Serial->Parallel".Data = Junction:A.Out2;  
 "Serial->Parallel".P_Type = "Parallel->Serial".P_Type;  
 "Serial->Parallel".Go = "Parallel->Serial".Shift_Out;  //_GUI 82,38, 82,35
 "Serial->Parallel".Wait = Input:C;  //_GUI 150,41, 150,47
 Junction:A = "Parallel->Serial".Data;  
}

Object ( Variant MidData, Bit Stobe, Bit Done
    , Bit Busy) "Test_P->S"( LSB016 Input, MSB004 S_Size, Bit Go
    , Bit Wait) 
//_Attributes TreeGroup=TestLib\Shifting
{
 //_ Object Prototypes
 Object ( LSB016 Input) Input;  //_GUI 28,33
 //_Attributes WidgetHex=True,WidgetWidth=164,WidgetHeight=49
 Object ( MSB004 S_Size) Input:A;  //_GUI 57,36
 Object ( Bit Go) Input:B;  //_GUI 29,41
 Object ( Bit Wait) Input:C;  //_GUI 79,57
 Object Output( Variant MidData) ;  //_GUI 90,26
 //_Attributes WidgetHex=True,WidgetWidth=104,WidgetHeight=49
 Object Output:A( Bit Stobe) ;  //_GUI 111,90
 Object Output:B( Bit Done) ;  //_GUI 82,95
 Object Output:C( Bit Busy) ;  //_GUI 66,100
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 89,33
 Object ( Bit Pulse) OneShot( Bit I, Bit ClkG) ;  //_GUI 42,40
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 110,42
 Object ( Variant Data, Variant P_Type, Bit Shift_Out
    , Bit Done, Bit Busy) "Parallel->Serial"( Variant Data, Variant S_Size
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 66,32

 // Behavior Topology
 Output = Junction.Out1;  
 Output:A = Junction:A.Out3;  
 Output:B = "Parallel->Serial".Done;  
 Output:C = "Parallel->Serial".Busy;  //_GUI 61,75, 61,46
 Junction = "Parallel->Serial".Data;  
 OneShot.I = Input:B;  
 Junction:A = "Parallel->Serial".Shift_Out;  //_GUI 91,43, 91,40
 "Parallel->Serial".Data = Input;  
 "Parallel->Serial".S_Size = Input:A;  
 "Parallel->Serial".Go = OneShot;  
 "Parallel->Serial".Wait = Input:C;  //_GUI 87,46, 87,58
}

Object ( Variant middat, Variant Data, Bit "S->P Busy"
    , Bit "P->S Done", Bit Done, Bit Busy) Test_Par_Ser( LSB064 Data
    , LSB008 S_Size, Bit ClkG, Bit I, Bit Wait) 
//_Attributes TreeGroup=TestLib\Shifting
{
 //_ Object Prototypes
 Object ( LSB064 Data) Input;  //_GUI 72,54
 //_Attributes WidgetHex=True,WidgetWidth=129,WidgetHeight=41
 Object ( LSB008 S_Size) Input:A;  //_GUI 71,57
 Object ( Bit ClkG) Input:B;  //_GUI 49,63
 Object ( Bit I) Input:C;  //_GUI 48,66
 Object ( Bit Wait) Input:D;  //_GUI 130,69
 Object Output( Variant middat) ;  //_GUI 108,28
 //_Attributes WidgetHex=True,WidgetWidth=124,WidgetHeight=50
 Object Output:A( Variant Data) ;  //_GUI 135,55
 //_Attributes WidgetHex=True,WidgetWidth=129,WidgetHeight=41
 Object Output:B( Bit "S->P Busy") ;  //_GUI 106,79
 Object Output:C( Bit "P->S Done") ;  //_GUI 111,83
 Object Output:D( Bit Done) ;  //_GUI 135,88
 Object Output:E( Bit Busy) ;  //_GUI 78,93
 Object ( Variant Data, Bit Done, Bit Busy) "Serial->Parallel_Clr"
    ( Variant Data, Variant P_Type, Bit AClr, Bit ClkG
    , Bit Go, Bit Wait) ;  //_GUI 116,53
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 58,63
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 107,54
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 110,66
 Object ( Variant Data, Variant P_Type, Bit Done
    , Bit Busy) "Parallel->Serial_Clr"( Variant Data, Variant S_Size, Bit AClr
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 78,53
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In2) ;  //_GUI 105,69

 // Behavior Topology
 Output = Junction:A.Out1;  
 Output:A = "Serial->Parallel_Clr".Data;  
 Output:B = Junction:C.Out3;  
 Output:C = Junction:B.Out3;  
 Output:D = "Serial->Parallel_Clr".Done;  //_GUI 135,78, 134,78
 Output:E = "Parallel->Serial_Clr".Busy;  
 "Serial->Parallel_Clr".Data = Junction:A.Out2;  
 "Serial->Parallel_Clr".P_Type = "Parallel->Serial_Clr".P_Type;  
 "Serial->Parallel_Clr".ClkG = Junction.Out1;  //_GUI 101,64, 101,43, 59,43
 "Serial->Parallel_Clr".Go = Junction:B.Out2;  
 "Serial->Parallel_Clr".Wait = Input:D;  
 Junction = Input:B;  
 Junction:A = "Parallel->Serial_Clr".Data;  
 Junction:B = "Parallel->Serial_Clr".Done;  
 "Parallel->Serial_Clr".Data = Input;  
 "Parallel->Serial_Clr".S_Size = Input:A;  
 "Parallel->Serial_Clr".ClkG = Junction.Out2;  
 "Parallel->Serial_Clr".Go = Input:C;  
 "Parallel->Serial_Clr".Wait = Junction:C.Out1;  
 Junction:C = "Serial->Parallel_Clr".Busy;  
}

Object ( Bit Bit, Bit Bit, Bit Bit) Test_get_LSB_bit
    ( Bit In1, Bit In2, LSB002 In3) 
//_Attributes TreeGroup=TestLib\GrammaticalOps
{
// Description:
// get_LSB_bit test sheet
//
// Date:
// March 10, 2004
 //_ Object Prototypes
 Object ( Bit In1) Input;  //_GUI 35,21
 Object ( Bit In2) Input:A;  //_GUI 35,31
 Object ( LSB002 In3) Input:B;  //_GUI 35,41
 Object Output( Bit Bit) ;  //_GUI 74,19
 Object Output:A( Bit Bit) ;  //_GUI 74,29
 Object Output:B( Bit Bit) ;  //_GUI 74,39
 Object ( Bit Bit) get_LSB_bit( Variant Data, Variant Lo_e) ;  //_GUI 50,27
 Object ( LSB002 Data) Input:C;  //_GUI 35,28
 //_Attributes Constant="*2"
 Object ( Bit Data) Input:D;  //_GUI 35,18
 //_Attributes Constant="*1"
 Object ( Bit Bit) get_LSB_bit:A( Variant Data, Variant Lo_e) ;  //_GUI 50,37
 Object ( LSB002 Data) Input:E;  //_GUI 35,38
 //_Attributes Constant="*2"
 Object ( Bit Bit) get_LSB_bit:B( Variant Data, Variant Lo_e) ;  //_GUI 50,17

 // Behavior Topology
 Output = get_LSB_bit:B;  
 Output:A = get_LSB_bit;  
 Output:B = get_LSB_bit:A;  
 get_LSB_bit.Data = Input:C;  
 get_LSB_bit.Lo_e = Input:A;  
 get_LSB_bit:A.Data = Input:E;  
 get_LSB_bit:A.Lo_e = Input:B;  
 get_LSB_bit:B.Data = Input:D;  
 get_LSB_bit:B.Lo_e = Input;  
}

Object ( Variant P, Variant Q, Variant P) Test_Context_on_list
    ( Fix32 A, LSB040 Binary) 
//_Attributes TreeGroup=TestLib\Convert
{
 //_ Object Prototypes
 Object ( Fix32 A) Input;  //_GUI 55,34
 Object ( LSB040 Binary) Input:A;  //_GUI 52,75
 Object Output( Variant P) ;  //_GUI 163,34
 Object Output:A( Variant Q) ;  //_GUI 130,45
 Object Output:B( Variant P) ;  //_GUI 171,75
 Object ( Variant Out1) LSB( Variant In1) ;  //_GUI 106,32
 Object ( List Out1, List Out2, List Out3) Junction
    ( List In0) ;  //_GUI 101,34
 Object ( Variant Out1) Context( Variant Type, Variant Data) ;  //_GUI 122,30
 Object ( Variant Out1) DynamicOut( Variant In1) ;  //_GUI 69,32
 Object ( Bit OFL, Variant Out1) StaticOut( Variant Type
    , Variant Data) ;  //_GUI 153,30
 Object ( Fixed Out) FixedOut( List In1) ;  //_GUI 139,32
 //_Attributes Primitive
 Object ( Fix32 Out1, Fix32 Out2, Fix32 Out3) Junction:A
    ( Fix32 In0) ;  //_GUI 63,34
 Object ( List Out1) FixedIn( Fixed In) ;  //_GUI 87,32
 //_Attributes Primitive
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 118,34
 Object ( Bit OFL, Variant Out1) StaticOut:A( Variant Type
    , Variant Data) ;  //_GUI 161,71
 Object ( Fixed Out) FixedOut:A( List In1) ;  //_GUI 147,73
 //_Attributes Primitive
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 44,61
 //_Attributes Primitive
 Object ( Variant C, Variant Out1) RCR( Variant In2
    , Variant C) ;  //_GUI 100,74
 //_Attributes Documentation=Bit_Carry
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 64,64
 //_Attributes Primitive
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 59,65
 Object ( Variant Out1) LSB:A( Variant In1) ;  //_GUI 80,64
 Object ( List Out) ListOut:A( Variant In1, Variant In2) ;  //_GUI 129,73
 //_Attributes Primitive
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 110,60
 Object Text;  //_GUI 187,32,Enter two numbers in A, multiply their Q in a calculator, put the calculator result into Binary, and see your multiply.

 // Behavior Topology
 Output = StaticOut.Out1;  
 Output:A = Junction:B.Out3;  //_GUI 119,46
 Output:B = StaticOut:A.Out1;  
 LSB = Junction.Out2;  
 Junction = FixedIn;  
 Context.Type = Junction.Out1;  //_GUI 122,24, 102,24
 Context.Data = Junction:B.Out2;  
 DynamicOut = Junction:A.Out2;  
 StaticOut.Type = Junction:A.Out1;  //_GUI 153,18, 64,18
 StaticOut.Data = FixedOut;  
 FixedOut = Context;  //_GUI 139,33
 Junction:A = Input;  
 FixedIn = DynamicOut;  
 Junction:B = LSB;  
 StaticOut:A.Type = Junction:A.Out3;  //_GUI 161,58, 64,58
 StaticOut:A.Data = FixedOut:A;  
 FixedOut:A = ListOut:A;  
 ListIn = Junction.Out3;  //_GUI 44,47, 102,47
 RCR.In2 = Input:A;  
 RCR.C = LSB:A;  //_GUI 90,79
 ListOut.In1 = Junction:C.Out3;  //_GUI 60,69
 ListOut.In2 = Junction:C.Out2;  
 Junction:C = ListIn.Out1;  
 LSB:A = ListOut;  
 ListOut:A.In1 = Cast;  //_GUI 120,78
 ListOut:A.In2 = RCR.Out1;  //_GUI 118,75, 118,79
 Cast.Type = Junction:C.Out1;  //_GUI 60,62
 Cast.Data = RCR.C;  
}

Object ( Variant Out1, Bit Busy) Test_convert_stalls( Float Data
    , Bit I, Bit Wait) 
//_Attributes TreeGroup=TestLib\Convert
{
// Description:
// Test the GDBW for the convert object.  This test shows that data is not lost in between states.
//
// Date:
// March 10, 2004
 //_ Object Prototypes
 Object ( Float Data) Input;  //_GUI 8,57
 Object ( Bit I) Input:A;  //_GUI 18,62
 Object ( Bit Wait) Input:B;  //_GUI 142,73
 Object Output( Variant Out1) ;  //_GUI 176,57
 Object Output:A( Bit Busy) ;  //_GUI 45,66
 Object ( Variant Out1) DynamicOut( Variant In1) ;  //_GUI 19,55
 Object ( Bit OFL, Variant Out1) StaticOut( Variant Type
    , Variant Data) ;  //_GUI 154,53
 Object ( Variant Q, Bit ClkG, Variant Done
    , Variant Busy) Register( Variant D, Bit ClkG, Variant Go
    , Variant Wait) ;  //_GUI 135,56
 //_Attributes Documentation=Var/Bit
 Object ( Float Out1, Float Out2, Float Out3) Junction
    ( Float In0) ;  //_GUI 14,57
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 35,57
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 67,41
 Object ( Fix32 Data) Input:C;  //_GUI 8,35
 //_Attributes Constant="*0"
 Object ( Variant Out1) DynamicOut:A( Variant In1) ;  //_GUI 27,33
 Object ( Bit Pulse) OneShot( Bit I, Bit ClkG) ;  //_GUI 22,61
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 116,53
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:A( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 68,53
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:B( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 91,53
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In1) ;  //_GUI 42,43
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:C( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 45,53
 Object Text;  //_GUI 43,9,instructions:1.  Assign a value to the data input.2.  Assert the wait signal.3.  Toggle the 'I' input.4.  Reassign 'Data'5.  Toggle 'I'6.  Bring 'Wait' low.Arial,8,0,1
 Object Text;  //_GUI 118,21,Note:  A value can be sent to the Register if 'Wait' is asserted only if no data has been latched in.  Once data is in the Register, the output value will not reassign until 'Wait' is brought low again.Arial,8,255,1

 // Behavior Topology
 Output = StaticOut.Out1;  
 Output:A = Convert:C.Busy;  
 DynamicOut = Junction.Out2;  
 StaticOut.Type = Junction.Out1;  //_GUI 154,47, 15,47
 StaticOut.Data = Register.Q;  
 Register.D = Convert.Out1;  
 Register.ClkG = Convert.ClkG;  
 Register.Go = Convert.Done;  
 Register.Wait = Input:B;  
 Junction = Input;  
 Junction:A = DynamicOut;  
 Junction:B = Junction:A.Out1;  //_GUI 36,42
 DynamicOut:A = Input:C;  
 OneShot.I = Input:A;  
 Convert.Type = Junction:B.Out2;  //_GUI 116,42
 Convert.Data = Convert:B.Out1;  
 Convert.ClkG = Convert:B.ClkG;  
 Convert.Go = Convert:B.Done;  
 Convert.Wait = Register.Busy;  
 Convert:A.Type = Junction:B.Out3;  
 Convert:A.Data = Convert:C.Out1;  
 Convert:A.ClkG = Convert:C.ClkG;  
 Convert:A.Go = Convert:C.Done;  
 Convert:A.Wait = Convert:B.Busy;  
 Convert:B.Type = Junction:C.Out2;  //_GUI 91,44
 Convert:B.Data = Convert:A.Out1;  
 Convert:B.ClkG = Convert:A.ClkG;  
 Convert:B.Go = Convert:A.Done;  
 Convert:B.Wait = Convert.Busy;  
 Junction:C = DynamicOut:A;  //_GUI 43,36
 Convert:C.Type = Junction:C.Out3;  //_GUI 43,55
 Convert:C.Data = Junction:A.Out2;  
 Convert:C.Go = OneShot;  
 Convert:C.Wait = Convert:A.Busy;  
}

Object ( Bit OFL_MSB032, Variant Q_MSB032, Bit "OFL_Signed(16)"
    , Variant "Q_Signed(16)", Bit "OFL_Fixed(8. 8)", Variant "Q_Fixed(8. 8)", Bit "OFL_Float(9 . 23)"
    , Variant "Q_Float(9 . 23)") "Test_Convert->Fixed(3,3)"( Fix32 "D_Fixed(16 . 16)", MSB032 D_MSB032, Int "D_Signed(16)"
    , Fix16 "D_Fixed(8. 8)", Float "D_Float(9 . 23)", Bit Go) 
//_Attributes TreeGroup=TestLib\Convert
{
// Date Last Modified:
// 08 Feb 2003
//
// Author:
// Samuel Brown
 //_ Object Prototypes
 Object ( Fix32 "D_Fixed(16 . 16)") Input;  //_GUI 21,19
 Object ( MSB032 D_MSB032) Input:A;  //_GUI 39,25
 Object ( Int "D_Signed(16)") Input:B;  //_GUI 26,44
 Object ( Fix16 "D_Fixed(8. 8)") Input:C;  //_GUI 27,64
 Object ( Float "D_Float(9 . 23)") Input:D;  //_GUI 30,81
 Object ( Bit Go) Input:E;  //_GUI 29,90
 Object Output( Bit OFL_MSB032) ;  //_GUI 119,22
 Object Output:A( Variant Q_MSB032) ;  //_GUI 119,33
 Object Output:B( Bit "OFL_Signed(16)") ;  //_GUI 119,41
 Object Output:C( Variant "Q_Signed(16)") ;  //_GUI 118,52
 Object Output:D( Bit "OFL_Fixed(8. 8)") ;  //_GUI 119,61
 Object Output:E( Variant "Q_Fixed(8. 8)") ;  //_GUI 119,72
 Object Output:F( Bit "OFL_Float(9 . 23)") ;  //_GUI 119,78
 Object Output:G( Variant "Q_Float(9 . 23)") ;  //_GUI 118,89
 Object ( Variant Q) RegEn( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 85,63
 Object ( Variant Q) RegEn:A( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 85,80
 Object ( Variant Out1) DynamicOut( Variant In1) ;  //_GUI 35,62
 Object ( Variant Out1) DynamicOut:A( Variant In1) ;  //_GUI 36,79
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 62,77
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In1) ;  //_GUI 54,61
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 54,22
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:A( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 62,40
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:B( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 62,21
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:C( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 62,60
 Object ( Variant Q) RegEn:B( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 85,43
 Object ( Bit Pulse) OneShot( Bit I, Bit ClkG) ;  //_GUI 35,89
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In3) ;  //_GUI 57,87
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In3) ;  //_GUI 57,50
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In3) ;  //_GUI 57,70
 Object ( Variant Q) RegEn:C( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 85,24
 Object ( Variant Out1) DynamicOut:B( Variant In1) ;  //_GUI 32,17
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In1) ;  //_GUI 54,41
 Object ( Variant Out1) DynamicOut:C( Variant In1) ;  //_GUI 34,42
 Object ( Bit OFL, Variant Out1) StaticOut( Variant Type
    , Variant Data) ;  //_GUI 104,85
 Object ( Bit OFL, Variant Out1) StaticOut:A( Variant Type
    , Variant Data) ;  //_GUI 104,68
 Object ( Bit OFL, Variant Out1) StaticOut:B( Variant Type
    , Variant Data) ;  //_GUI 104,48
 Object ( Bit OFL, Variant Out1) StaticOut:C( Variant Type
    , Variant Data) ;  //_GUI 104,29
 Object ( Fix32 Out1, Fix32 Out2, Fix32 Out3) Junction:F
    ( Fix32 In0) ;  //_GUI 28,19
 Object ( Fix32 Out1, Fix32 Out2, Fix32 Out3) Junction:G
    ( Fix32 In1) ;  //_GUI 98,69
 Object ( Fix32 Out1, Fix32 Out2, Fix32 Out3) Junction:H
    ( Fix32 In1) ;  //_GUI 98,49
 Object ( Fix32 Out1, Fix32 Out2, Fix32 Out3) Junction:I
    ( Fix32 In1) ;  //_GUI 98,30

 // Behavior Topology
 Output = Convert:B.OFL;  
 Output:A = StaticOut:C.Out1;  
 Output:B = Convert:A.OFL;  
 Output:C = StaticOut:B.Out1;  
 Output:D = Convert:C.OFL;  
 Output:E = StaticOut:A.Out1;  
 Output:F = Convert.OFL;  
 Output:G = StaticOut.Out1;  
 RegEn.D = Convert:C.Out1;  
 RegEn.EN = Convert:C.Done;  
 RegEn:A.D = Convert.Out1;  
 RegEn:A.EN = Convert.Done;  
 DynamicOut = Input:C;  
 DynamicOut:A = Input:D;  
 Convert.Type = Junction.Out3;  //_GUI 55,79
 Convert.Data = DynamicOut:A;  
 Convert.Go = Junction:B.Out3;  
 Junction = Junction:E.Out3;  
 Junction:A = DynamicOut:B;  //_GUI 49,23, 49,20
 Convert:A.Type = Junction:E.Out2;  
 Convert:A.Data = DynamicOut:C;  
 Convert:A.Go = Junction:C.Out3;  
 Convert:B.Type = Junction:A.Out2;  
 Convert:B.Data = Input:A;  
 Convert:B.Go = Junction:C.Out2;  //_GUI 58,32
 Convert:C.Type = Junction.Out2;  
 Convert:C.Data = DynamicOut;  
 Convert:C.Go = Junction:D.Out3;  
 RegEn:B.D = Convert:A.Out1;  
 RegEn:B.EN = Convert:A.Done;  
 OneShot.I = Input:E;  
 Junction:B = OneShot;  //_GUI 58,92
 Junction:C = Junction:D.Out2;  
 Junction:D = Junction:B.Out2;  
 RegEn:C.D = Convert:B.Out1;  
 RegEn:C.EN = Convert:B.Done;  
 DynamicOut:B = Junction:F.Out2;  
 Junction:E = Junction:A.Out3;  
 DynamicOut:C = Input:B;  
 StaticOut.Type = Junction:G.Out3;  //_GUI 99,87
 StaticOut.Data = RegEn:A;  //_GUI 100,90, 100,83
 StaticOut:A.Type = Junction:G.Out2;  
 StaticOut:A.Data = RegEn;  //_GUI 100,73, 100,66
 StaticOut:B.Type = Junction:H.Out2;  
 StaticOut:B.Data = RegEn:B;  //_GUI 100,53, 100,46
 StaticOut:C.Type = Junction:I.Out2;  
 StaticOut:C.Data = RegEn:C;  //_GUI 100,34, 100,27
 Junction:F = Input;  
 Junction:G = Junction:H.Out3;  
 Junction:H = Junction:I.Out3;  
 Junction:I = Junction:F.Out1;  //_GUI 99,14, 29,14
}

Object ( Bit OFL_MSB032, Variant Q_MSB032, Bit "OFL_Signed(16)"
    , Variant "Q_Signed(16)", Bit "OFL_Fixed(16 . 16)", Variant "Q_Fixed(16 . 16)", Bit "OFL_Float(11 . 53)"
    , Variant "Q_Float(11. 53)") "Test_Convert->Floating(3,3)"( Float "D_Float(9 . 23)", MSB032 D_MSB032, Int "D_Signed(16)"
    , Fix32 "D_Fixed(16 . 16)", Double "D_Float(11. 53)", Bit Go) 
//_Attributes TreeGroup=TestLib\Convert
{
// Date Last Modified:
// 08 Feb 2003
//
// Author:
// Samuel Brown
 //_ Object Prototypes
 Object ( Float "D_Float(9 . 23)") Input;  //_GUI 20,19
 Object ( MSB032 D_MSB032) Input:A;  //_GUI 39,25
 Object ( Int "D_Signed(16)") Input:B;  //_GUI 26,44
 Object ( Fix32 "D_Fixed(16 . 16)") Input:C;  //_GUI 29,63
 Object ( Double "D_Float(11. 53)") Input:D;  //_GUI 30,81
 Object ( Bit Go) Input:E;  //_GUI 29,90
 Object Output( Bit OFL_MSB032) ;  //_GUI 119,22
 Object Output:A( Variant Q_MSB032) ;  //_GUI 119,33
 Object Output:B( Bit "OFL_Signed(16)") ;  //_GUI 119,41
 Object Output:C( Variant "Q_Signed(16)") ;  //_GUI 118,52
 Object Output:D( Bit "OFL_Fixed(16 . 16)") ;  //_GUI 121,61
 Object Output:E( Variant "Q_Fixed(16 . 16)") ;  //_GUI 121,72
 Object Output:F( Bit "OFL_Float(11 . 53)") ;  //_GUI 119,78
 Object Output:G( Variant "Q_Float(11. 53)") ;  //_GUI 118,89
 Object ( Variant Out1) DynamicOut( Variant In1) ;  //_GUI 36,79
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 62,77
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In1) ;  //_GUI 54,61
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 54,22
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:A( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 62,40
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:B( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 62,21
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:C( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 62,60
 Object ( Variant Q) RegEn( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 85,80
 Object ( Bit Pulse) OneShot( Bit I, Bit ClkG) ;  //_GUI 35,89
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In3) ;  //_GUI 57,87
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In3) ;  //_GUI 57,50
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In3) ;  //_GUI 57,70
 Object ( Variant Q) RegEn:A( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 85,24
 Object ( Variant Out1) DynamicOut:A( Variant In1) ;  //_GUI 32,17
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In1) ;  //_GUI 54,41
 Object ( Variant Out1) DynamicOut:B( Variant In1) ;  //_GUI 34,42
 Object ( Bit OFL, Variant Out1) StaticOut( Variant Type
    , Variant Data) ;  //_GUI 104,85
 Object ( Bit OFL, Variant Out1) StaticOut:A( Variant Type
    , Variant Data) ;  //_GUI 104,68
 Object ( Bit OFL, Variant Out1) StaticOut:B( Variant Type
    , Variant Data) ;  //_GUI 104,48
 Object ( Bit OFL, Variant Out1) StaticOut:C( Variant Type
    , Variant Data) ;  //_GUI 104,29
 Object ( Float Out1, Float Out2, Float Out3) Junction:F
    ( Float In0) ;  //_GUI 28,19
 Object ( Float Out1, Float Out2, Float Out3) Junction:G
    ( Float In1) ;  //_GUI 98,69
 Object ( Float Out1, Float Out2, Float Out3) Junction:H
    ( Float In1) ;  //_GUI 98,49
 Object ( Float Out1, Float Out2, Float Out3) Junction:I
    ( Float In1) ;  //_GUI 98,30
 Object ( Variant Q) RegEn:B( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 85,43
 Object ( Variant Out1) DynamicOut:C( Variant In1) ;  //_GUI 35,61
 Object ( Variant Q) RegEn:C( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 85,63

 // Behavior Topology
 Output = Convert:B.OFL;  
 Output:A = StaticOut:C.Out1;  
 Output:B = Convert:A.OFL;  
 Output:C = StaticOut:B.Out1;  
 Output:D = Convert:C.OFL;  
 Output:E = StaticOut:A.Out1;  
 Output:F = Convert.OFL;  
 Output:G = StaticOut.Out1;  
 DynamicOut = Input:D;  
 Convert.Type = Junction.Out3;  //_GUI 55,79
 Convert.Data = DynamicOut;  
 Convert.Go = Junction:B.Out3;  
 Junction = Junction:E.Out3;  
 Junction:A = DynamicOut:A;  //_GUI 49,23, 49,20
 Convert:A.Type = Junction:E.Out2;  
 Convert:A.Data = DynamicOut:B;  
 Convert:A.Go = Junction:C.Out3;  
 Convert:B.Type = Junction:A.Out2;  
 Convert:B.Data = Input:A;  
 Convert:B.Go = Junction:C.Out2;  //_GUI 58,32
 Convert:C.Type = Junction.Out2;  
 Convert:C.Data = DynamicOut:C;  //_GUI 48,65
 Convert:C.Go = Junction:D.Out3;  
 RegEn.D = Convert.Out1;  
 RegEn.EN = Convert.Done;  
 OneShot.I = Input:E;  
 Junction:B = OneShot;  //_GUI 58,92
 Junction:C = Junction:D.Out2;  
 Junction:D = Junction:B.Out2;  
 RegEn:A.D = Convert:B.Out1;  
 RegEn:A.EN = Convert:B.Done;  
 DynamicOut:A = Junction:F.Out2;  
 Junction:E = Junction:A.Out3;  
 DynamicOut:B = Input:B;  
 StaticOut.Type = Junction:G.Out3;  //_GUI 99,87
 StaticOut.Data = RegEn;  //_GUI 100,90, 100,83
 StaticOut:A.Type = Junction:G.Out2;  
 StaticOut:A.Data = RegEn:C;  //_GUI 100,73, 100,66
 StaticOut:B.Type = Junction:H.Out2;  
 StaticOut:B.Data = RegEn:B;  //_GUI 100,53, 100,46
 StaticOut:C.Type = Junction:I.Out2;  
 StaticOut:C.Data = RegEn:A;  //_GUI 100,34, 100,27
 Junction:F = Input;  
 Junction:G = Junction:H.Out3;  
 Junction:H = Junction:I.Out3;  
 Junction:I = Junction:F.Out1;  //_GUI 99,14, 29,14
 RegEn:B.D = Convert:A.Out1;  
 RegEn:B.EN = Convert:A.Done;  
 DynamicOut:C = Input:C;  
 RegEn:C.D = Convert:C.Out1;  
 RegEn:C.EN = Convert:C.Done;  
}

Object ( Bit OFL_MSB008, Variant Q_MSB008, Bit OFL_MSB032
    , Variant Q_MSB032, Bit "OFL_Signed(16)", Variant "Q_Signed(16)", Bit "OFL_Fixed(16 . 16)"
    , Variant "Q_Fixed(16 . 16)", Bit "OFL_Float(9 . 23)", Variant "Q_Float(9 . 23)") "Test_Convert->Num(3,3)"( MSB008 D_MSB008
    , MSB032 D_MSB032, Int "D_Signed(16)", Fix32 "D_Fixed(16 . 16)", Float "D_Float(9 . 23)"
    , Bit Go) 
//_Attributes TreeGroup=TestLib\Convert
{
// Date Last Modified:
// 08 Feb 2003
//
// Author:
// Samuel Brown
 //_ Object Prototypes
 Object ( MSB008 D_MSB008) Input;  //_GUI 40,25
 Object ( MSB032 D_MSB032) Input:A;  //_GUI 39,44
 Object ( Int "D_Signed(16)") Input:B;  //_GUI 27,62
 Object ( Fix32 "D_Fixed(16 . 16)") Input:C;  //_GUI 29,81
 Object ( Float "D_Float(9 . 23)") Input:D;  //_GUI 30,98
 Object ( Bit Go) Input:E;  //_GUI 29,107
 Object Output( Bit OFL_MSB008) ;  //_GUI 101,22
 Object Output:A( Variant Q_MSB008) ;  //_GUI 101,26
 Object Output:B( Bit OFL_MSB032) ;  //_GUI 101,41
 Object Output:C( Variant Q_MSB032) ;  //_GUI 101,45
 Object Output:D( Bit "OFL_Signed(16)") ;  //_GUI 101,59
 Object Output:E( Variant "Q_Signed(16)") ;  //_GUI 101,63
 Object Output:F( Bit "OFL_Fixed(16 . 16)") ;  //_GUI 101,78
 Object Output:G( Variant "Q_Fixed(16 . 16)") ;  //_GUI 101,82
 Object Output:H( Bit "OFL_Float(9 . 23)") ;  //_GUI 101,95
 Object Output:I( Variant "Q_Float(9 . 23)") ;  //_GUI 101,99
 Object ( MSB016 Out1, MSB016 Out2, MSB016 Out3) Junction
    ( MSB016 In1) ;  //_GUI 54,41
 Object ( Variant Q) RegEn( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 85,24
 Object ( Variant Q) RegEn:A( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 85,43
 Object ( Variant Q) RegEn:B( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 85,61
 Object ( Variant Q) RegEn:C( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 85,80
 Object ( Variant Q) RegEn:D( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 85,97
 Object ( Variant Out1) DynamicOut( Variant In1) ;  //_GUI 35,79
 Object ( Variant Out1) DynamicOut:A( Variant In1) ;  //_GUI 35,60
 Object ( Variant Out1) DynamicOut:B( Variant In1) ;  //_GUI 36,96
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 62,94
 Object ( MSB016 Out1, MSB016 Out2, MSB016 Out3) Junction:A
    ( MSB016 In1) ;  //_GUI 54,78
 Object ( MSB016 Out1, MSB016 Out2, MSB016 Out3) Junction:B
    ( MSB016 In0) ;  //_GUI 54,22
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:A( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 62,40
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:B( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 62,21
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:C( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 62,58
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:D( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 62,77
 Object ( MSB016 MSB016) Input:F;  //_GUI 41,19
 //_Attributes Constant="*0"
 Object ( MSB016 Out1, MSB016 Out2, MSB016 Out3) Junction:C
    ( MSB016 In1) ;  //_GUI 54,59
 Object ( Bit Pulse) OneShot( Bit I, Bit ClkG) ;  //_GUI 35,106
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In3) ;  //_GUI 57,104
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:E
    ( Bit In3) ;  //_GUI 57,50
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:F
    ( Bit In3) ;  //_GUI 57,68
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:G
    ( Bit In3) ;  //_GUI 57,87

 // Behavior Topology
 Output = Convert:B.OFL;  
 Output:A = RegEn;  
 Output:B = Convert:A.OFL;  
 Output:C = RegEn:A;  
 Output:D = Convert:C.OFL;  
 Output:E = RegEn:B;  
 Output:F = Convert:D.OFL;  
 Output:G = RegEn:C;  
 Output:H = Convert.OFL;  
 Output:I = RegEn:D;  
 Junction = Junction:B.Out3;  
 RegEn.D = Convert:B.Out1;  
 RegEn.EN = Convert:B.Done;  
 RegEn:A.D = Convert:A.Out1;  
 RegEn:A.EN = Convert:A.Done;  
 RegEn:B.D = Convert:C.Out1;  
 RegEn:B.EN = Convert:C.Done;  
 RegEn:C.D = Convert:D.Out1;  
 RegEn:C.EN = Convert:D.Done;  
 RegEn:D.D = Convert.Out1;  
 RegEn:D.EN = Convert.Done;  
 DynamicOut = Input:C;  
 DynamicOut:A = Input:B;  
 DynamicOut:B = Input:D;  
 Convert.Type = Junction:A.Out3;  //_GUI 55,96
 Convert.Data = DynamicOut:B;  
 Convert.Go = Junction:D.Out3;  
 Junction:A = Junction:C.Out3;  
 Junction:B = Input:F;  //_GUI 49,23, 49,20
 Convert:A.Type = Junction.Out2;  
 Convert:A.Data = Input:A;  
 Convert:A.Go = Junction:E.Out3;  
 Convert:B.Type = Junction:B.Out2;  
 Convert:B.Data = Input;  
 Convert:B.Go = Junction:E.Out2;  //_GUI 58,32
 Convert:C.Type = Junction:C.Out2;  
 Convert:C.Data = DynamicOut:A;  
 Convert:C.Go = Junction:F.Out3;  
 Convert:D.Type = Junction:A.Out2;  
 Convert:D.Data = DynamicOut;  
 Convert:D.Go = Junction:G.Out3;  
 Junction:C = Junction.Out3;  
 OneShot.I = Input:E;  
 Junction:D = OneShot;  //_GUI 58,109
 Junction:E = Junction:F.Out2;  
 Junction:F = Junction:G.Out2;  
 Junction:G = Junction:D.Out2;  
}

Object ( Bit OFL_MSB032, Variant Q_MSB032, Bit "OFL_Signed(16)"
    , Variant "Q_Signed(16)", Bit "OFL_Fixed(16 . 16)", Variant "Q_Fixed(16 . 16)", Bit "OFL_Float(9 . 23)"
    , Variant "Q_Float(9 . 23)") "Test_Convert->Signed(3,3)"( Int "Signed(32)", MSB032 D_MSB032, Int "D_Signed(16)"
    , Fix32 "D_Fixed(16 . 16)", Float "D_Float(9 . 23)", Bit Go) 
//_Attributes TreeGroup=TestLib\Convert
{
// Date Last Modified:
// 08 Feb 2003
//
// Author:
// Samuel Brown
 //_ Object Prototypes
 Object ( Int "Signed(32)") Input;  //_GUI 23,19
 Object ( MSB032 D_MSB032) Input:A;  //_GUI 39,25
 Object ( Int "D_Signed(16)") Input:B;  //_GUI 26,44
 Object ( Fix32 "D_Fixed(16 . 16)") Input:C;  //_GUI 29,64
 Object ( Float "D_Float(9 . 23)") Input:D;  //_GUI 30,81
 Object ( Bit Go) Input:E;  //_GUI 29,90
 Object Output( Bit OFL_MSB032) ;  //_GUI 119,22
 Object Output:A( Variant Q_MSB032) ;  //_GUI 119,33
 Object Output:B( Bit "OFL_Signed(16)") ;  //_GUI 119,41
 Object Output:C( Variant "Q_Signed(16)") ;  //_GUI 118,52
 Object Output:D( Bit "OFL_Fixed(16 . 16)") ;  //_GUI 119,61
 Object Output:E( Variant "Q_Fixed(16 . 16)") ;  //_GUI 119,72
 Object Output:F( Bit "OFL_Float(9 . 23)") ;  //_GUI 119,78
 Object Output:G( Variant "Q_Float(9 . 23)") ;  //_GUI 118,89
 Object ( Variant Q) RegEn( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 85,63
 Object ( Variant Q) RegEn:A( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 85,80
 Object ( Variant Out1) DynamicOut( Variant In1) ;  //_GUI 35,62
 Object ( Variant Out1) DynamicOut:A( Variant In1) ;  //_GUI 36,79
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 62,77
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In1) ;  //_GUI 54,61
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 54,22
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:A( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 62,40
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:B( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 62,21
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:C( Variant Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 62,60
 Object ( Variant Q) RegEn:B( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 85,43
 Object ( Bit Pulse) OneShot( Bit I, Bit ClkG) ;  //_GUI 35,89
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In3) ;  //_GUI 57,87
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In3) ;  //_GUI 57,50
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In3) ;  //_GUI 57,70
 Object ( Variant Q) RegEn:C( Variant D, Bit ClkG
    , Bit EN) ;  //_GUI 85,24
 Object ( Variant Out1) DynamicOut:B( Variant In1) ;  //_GUI 32,17
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:E
    ( Variant In1) ;  //_GUI 54,41
 Object ( Variant Out1) DynamicOut:C( Variant In1) ;  //_GUI 34,42
 Object ( Bit OFL, Variant Out1) StaticOut( Variant Type
    , Variant Data) ;  //_GUI 104,85
 Object ( Bit OFL, Variant Out1) StaticOut:A( Variant Type
    , Variant Data) ;  //_GUI 104,68
 Object ( Bit OFL, Variant Out1) StaticOut:B( Variant Type
    , Variant Data) ;  //_GUI 104,48
 Object ( Bit OFL, Variant Out1) StaticOut:C( Variant Type
    , Variant Data) ;  //_GUI 104,29
 Object ( Int Out1, Int Out2, Int Out3) Junction:F
    ( Int In0) ;  //_GUI 28,19
 Object ( Int Out1, Int Out2, Int Out3) Junction:G
    ( Int In1) ;  //_GUI 98,69
 Object ( Int Out1, Int Out2, Int Out3) Junction:H
    ( Int In1) ;  //_GUI 98,49
 Object ( Int Out1, Int Out2, Int Out3) Junction:I
    ( Int In1) ;  //_GUI 98,30

 // Behavior Topology
 Output = Convert:B.OFL;  
 Output:A = StaticOut:C.Out1;  
 Output:B = Convert:A.OFL;  
 Output:C = StaticOut:B.Out1;  
 Output:D = Convert:C.OFL;  
 Output:E = StaticOut:A.Out1;  
 Output:F = Convert.OFL;  
 Output:G = StaticOut.Out1;  
 RegEn.D = Convert:C.Out1;  
 RegEn.EN = Convert:C.Done;  
 RegEn:A.D = Convert.Out1;  
 RegEn:A.EN = Convert.Done;  
 DynamicOut = Input:C;  
 DynamicOut:A = Input:D;  
 Convert.Type = Junction.Out3;  //_GUI 55,79
 Convert.Data = DynamicOut:A;  
 Convert.Go = Junction:B.Out3;  
 Junction = Junction:E.Out3;  
 Junction:A = DynamicOut:B;  //_GUI 49,23, 49,20
 Convert:A.Type = Junction:E.Out2;  
 Convert:A.Data = DynamicOut:C;  
 Convert:A.Go = Junction:C.Out3;  
 Convert:B.Type = Junction:A.Out2;  
 Convert:B.Data = Input:A;  
 Convert:B.Go = Junction:C.Out2;  //_GUI 58,32
 Convert:C.Type = Junction.Out2;  
 Convert:C.Data = DynamicOut;  
 Convert:C.Go = Junction:D.Out3;  
 RegEn:B.D = Convert:A.Out1;  
 RegEn:B.EN = Convert:A.Done;  
 OneShot.I = Input:E;  
 Junction:B = OneShot;  //_GUI 58,92
 Junction:C = Junction:D.Out2;  
 Junction:D = Junction:B.Out2;  
 RegEn:C.D = Convert:B.Out1;  
 RegEn:C.EN = Convert:B.Done;  
 DynamicOut:B = Junction:F.Out2;  
 Junction:E = Junction:A.Out3;  
 DynamicOut:C = Input:B;  
 StaticOut.Type = Junction:G.Out3;  //_GUI 99,87
 StaticOut.Data = RegEn:A;  //_GUI 100,90, 100,83
 StaticOut:A.Type = Junction:G.Out2;  
 StaticOut:A.Data = RegEn;  //_GUI 100,73, 100,66
 StaticOut:B.Type = Junction:H.Out2;  
 StaticOut:B.Data = RegEn:B;  //_GUI 100,53, 100,46
 StaticOut:C.Type = Junction:I.Out2;  
 StaticOut:C.Data = RegEn:C;  //_GUI 100,34, 100,27
 Junction:F = Input;  
 Junction:G = Junction:H.Out3;  
 Junction:H = Junction:I.Out3;  
 Junction:I = Junction:F.Out1;  //_GUI 99,14, 29,14
}

Object ( Bit ClkG, Variant Q, Bit Done
    , Bit Busy) Test_StaticOut_Signed( Int A, Bit ClkG, Bit Go
    , Bit Wait) 
//_Attributes TreeGroup=TestLib\Convert
{
 //_ Object Prototypes
 Object ( Int A) Input;  //_GUI 67,49
 Object ( Bit ClkG) Input:A;  //_GUI 135,49
 Object ( Bit Go) Input:B;  //_GUI 135,52
 Object ( Bit Wait) Input:C;  //_GUI 148,55
 Object Output( Bit ClkG) ;  //_GUI 154,49
 Object Output:A( Variant Q) ;  //_GUI 197,54
 Object Output:B( Bit Done) ;  //_GUI 154,60
 Object Output:C( Bit Busy) ;  //_GUI 141,65
 Object ( Variant Q, Bit ClkG, Bit Done
    , Bit Busy) Register( Variant D, Bit ClkG, Bit Go
    , Bit Wait) ;  //_GUI 141,45
 //_Attributes Documentation=$Bit
 Object ( Int Out1, Int Out2, Int Out3) Junction
    ( Int In0) ;  //_GUI 73,49
 Object ( Bit OFL, Variant Out1) StaticOut( Variant Type
    , Variant Data) ;  //_GUI 185,50
 Object ( Variant Out1) DynamicOut( Variant In1) ;  //_GUI 82,47

 // Behavior Topology
 Output = Register.ClkG;  
 Output:A = StaticOut.Out1;  
 Output:B = Register.Done;  //_GUI 152,61
 Output:C = Register.Busy;  
 Register.D = DynamicOut;  //_GUI 118,47, 118,50
 Register.ClkG = Input:A;  
 Register.Go = Input:B;  
 Register.Wait = Input:C;  
 Junction = Input;  
 StaticOut.Type = Junction.Out1;  //_GUI 177,52, 177,27, 74,27
 StaticOut.Data = Register.Q;  //_GUI 173,55, 173,47
 DynamicOut = Junction.Out2;  
}

Object ( Variant Output, Variant Done, Bit Busy) Ex_ConvertGDBW
    ( MSB016 MSB016, Fix32 Fix32, Int Int, Float Float
    , Bit Go, Bit Wait) 
//_Attributes TreeGroup=TestLib\Convert
{
 //_ Object Prototypes
 Object ( MSB016 MSB016) Input;  //_GUI 34,26
 Object ( Fix32 Fix32) Input:A;  //_GUI 34,34
 Object ( Int Int) Input:B;  //_GUI 34,42
 Object ( Float Float) Input:C;  //_GUI 34,50
 Object ( Bit Go) Input:D;  //_GUI 60,74
 Object ( Bit Wait) Input:E;  //_GUI 189,89
 Object Output( Variant Output) ;  //_GUI 220,69
 Object Output:A( Variant Done) ;  //_GUI 220,75
 Object Output:B( Bit Busy) ;  //_GUI 90,88
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 101,53
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 133,53
 Object ( Bit OFL, Variant Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert( Variant Type, Floating Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 150,65
 //_Attributes Documentation=Floating->Num
 Object ( Bit OFL, Floating Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:A( Floating Type, Fixed Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 134,65
 //_Attributes Documentation=Fixed->Floating
 Object ( Variant Out1) DynamicOut( Variant In1) ;  //_GUI 52,32
 Object ( Bit OFL, Signed Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:B( Signed Type, Floating Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 86,65
 //_Attributes Documentation=Floating->Signed
 Object ( Variant Out1) DynamicOut:A( Variant In1) ;  //_GUI 52,40
 Object ( Variant Q, Bit ClkG, Variant Done
    , Variant Busy) Register( Variant D, Bit ClkG, Variant Go
    , Variant Wait) ;  //_GUI 183,68
 //_Attributes Documentation=Var/Bit
 Object ( Bit OFL, Variant Out1) StaticOut( Variant Type
    , Variant Data) ;  //_GUI 205,65
 Object ( Variant Out1) DynamicOut:B( Variant In1) ;  //_GUI 52,48
 Object ( Bit OFL, Floating Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:C( Floating Type, Signed Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 102,65
 //_Attributes Documentation=Signed->Floating
 Object ( Bit OFL, Fixed Q, Bit ClkG
    , Bit Done, Bit Busy) Convert:D( Fixed Type, Floating Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 118,65
 //_Attributes Documentation=Floating->Fixed
 Object ( Float Out1, Float Out2, Float Out3) Junction:B
    ( Float In0) ;  //_GUI 44,50
 Object ( Bit OFL, Floating Out1, Bit ClkG
    , Bit Done, Bit Busy) Convert:E( Floating Type, Variant Data
    , Bit ClkG, Bit Go, Bit Wait) ;  //_GUI 166,65
 //_Attributes Documentation=Num->Floating
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 80,69
 Object ( Bit Pulse) OneShot( Bit I, Bit ClkG) ;  //_GUI 66,73

 // Behavior Topology
 Output = StaticOut.Out1;  
 Output:A = Register.Done;  
 Output:B = Convert:B.Busy;  //_GUI 80,89, 80,79
 Junction = Junction:C.Out1;  //_GUI 81,54
 Junction:A = Junction.Out2;  
 Convert.Type = Input;  //_GUI 150,27
 Convert.Data = Convert:A.Out1;  
 Convert.ClkG = Convert:A.ClkG;  
 Convert.Go = Convert:A.Done;  
 Convert.Wait = Convert:E.Busy;  
 Convert:A.Type = Junction:A.Out3;  
 Convert:A.Data = Convert:D.Q;  
 Convert:A.ClkG = Convert:D.ClkG;  
 Convert:A.Go = Convert:D.Done;  
 Convert:A.Wait = Convert.Busy;  
 DynamicOut = Input:A;  
 Convert:B.Type = DynamicOut:A;  //_GUI 86,43
 Convert:B.Data = Junction:C.Out2;  
 Convert:B.Go = OneShot;  
 Convert:B.Wait = Convert:C.Busy;  
 DynamicOut:A = Input:B;  
 Register.D = Convert:E.Out1;  
 Register.ClkG = Convert:E.ClkG;  
 Register.Go = Convert:E.Done;  
 Register.Wait = Input:E;  //_GUI 202,79, 202,90
 StaticOut.Type = Junction:B.Out3;  //_GUI 200,67, 200,83, 45,83
 StaticOut.Data = Register.Q;  
 DynamicOut:B = Junction:B.Out2;  
 Convert:C.Type = Junction.Out3;  
 Convert:C.Data = Convert:B.Out1;  
 Convert:C.ClkG = Convert:B.ClkG;  
 Convert:C.Go = Convert:B.Done;  
 Convert:C.Wait = Convert:D.Busy;  
 Convert:D.Type = DynamicOut;  //_GUI 118,35
 Convert:D.Data = Convert:C.Out1;  
 Convert:D.ClkG = Convert:C.ClkG;  
 Convert:D.Go = Convert:C.Done;  
 Convert:D.Wait = Convert:A.Busy;  
 Junction:B = Input:C;  
 Convert:E.Type = Junction:A.Out2;  //_GUI 166,54
 Convert:E.Data = Convert.Out1;  
 Convert:E.ClkG = Convert.ClkG;  
 Convert:E.Go = Convert.Done;  
 Convert:E.Wait = Register.Busy;  
 Junction:C = DynamicOut:B;  //_GUI 73,70, 73,51
 OneShot.I = Input:D;  
}

Object ( Variant Iteration, Variant Count, Variant Iteration
    , Bit Wait, Bit Done) Test_DoneForN_Iterations( Bit ClkG, Bit I) 
//_Attributes TreeGroup=TestLib\Control
{
// Description:
// Iteration test
//
// Date:
// March 11, 2004
 //_ Object Prototypes
 Object ( Bit ClkG) Input;  //_GUI 40,43
 Object ( Bit I) Input:A;  //_GUI 40,49
 Object Output( Variant Iteration) ;  //_GUI 148,33
 Object Output:A( Variant Count) ;  //_GUI 204,39
 Object Output:B( Variant Iteration) ;  //_GUI 91,40
 Object Output:C( Bit Wait) ;  //_GUI 114,49
 Object Output:D( Bit Done) ;  //_GUI 114,57
 Object ( LSB003 Iterations) Input:B;  //_GUI 40,40
 //_Attributes Constant="*3"
 Object ( Bit CO, Variant Count) Count( Variant CBy
    , Bit ClkG, Bit EN, Bit CLR) ;  //_GUI 179,35
 Object ( LSB008 Iterations) Input:C;  //_GUI 166,36
 //_Attributes Constant="*1"
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 64,43
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 90,35
 Object ( LSB003 Iterations) Input:D;  //_GUI 40,33
 //_Attributes Constant="*3"
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In1) ;  //_GUI 105,49
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 95,49
 Object ( Variant Iteration, Bit LastDone, Bit Done
    , Variant Busy) DoneForN_Down( Variant Iterations, Bit ClkG, Bit AClrG
    , Variant Go, Bit Wait) ;  //_GUI 69,39
 Object ( Variant Iteration, Bit LastDone, Bit Done
    , Variant Busy) DoneForN_Down:A( Variant Iterations, Bit ClkG, Bit AClrG
    , Variant Go, Bit Wait) ;  //_GUI 112,32

 // Behavior Topology
 Output = DoneForN_Down:A.Iteration;  
 Output:A = Count.Count;  
 Output:B = DoneForN_Down.Iteration;  
 Output:C = Junction:B.Out2;  
 Output:D = Junction:C.Out3;  //_GUI 96,58
 Count.CBy = Input:C;  
 Count.ClkG = Junction:A.Out1;  //_GUI 138,40, 138,23, 91,23
 Count.EN = DoneForN_Down:A.Done;  
 Junction = Input;  
 Junction:A = Junction.Out1;  //_GUI 65,36
 Junction:B = DoneForN_Down:A.Busy;  //_GUI 106,46
 Junction:C = DoneForN_Down.Done;  
 DoneForN_Down.Iterations = Input:B;  
 DoneForN_Down.ClkG = Junction.Out2;  
 DoneForN_Down.Go = Input:A;  
 DoneForN_Down.Wait = Junction:B.Out3;  //_GUI 106,53
 DoneForN_Down:A.Iterations = Input:D;  
 DoneForN_Down:A.ClkG = Junction:A.Out2;  //_GUI 103,37, 103,36
 DoneForN_Down:A.Go = Junction:C.Out2;  //_GUI 104,43, 104,50
}

Object ( Bit GoOne, Bit B, Bit Going
    , Bit D, Bit GoOne, Bit B, Bit Going
    , Bit D) Test_GDBW_Clr( Bit ClkG, Bit G, Bit W
    , Bit DoneIn, Bit AClr) 
//_Attributes TreeGroup=TestLib\Control
{
// Description:
// Test for GDBW_Clr and GDBW_Clr_alt.
//
// Date:
// March 10, 2004
 //_ Object Prototypes
 Object ( Bit ClkG) Input;  //_GUI 20,18
 Object ( Bit G) Input:A;  //_GUI 20,21
 Object ( Bit W) Input:B;  //_GUI 20,24
 Object ( Bit DoneIn) Input:C;  //_GUI 20,27
 Object ( Bit AClr) Input:D;  //_GUI 20,30
 Object Output( Bit GoOne) ;  //_GUI 62,18
 Object Output:A( Bit B) ;  //_GUI 62,21
 Object Output:B( Bit Going) ;  //_GUI 62,24
 Object Output:C( Bit D) ;  //_GUI 62,27
 Object Output:D( Bit GoOne) ;  //_GUI 62,37
 Object Output:E( Bit B) ;  //_GUI 62,40
 Object Output:F( Bit Going) ;  //_GUI 62,43
 Object Output:G( Bit D) ;  //_GUI 62,46
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction
    ( Bit In0) ;  //_GUI 31,27
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:A
    ( Bit In0) ;  //_GUI 34,24
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:B
    ( Bit In0) ;  //_GUI 37,21
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:C
    ( Bit In0) ;  //_GUI 40,18
 Object ( Bit GoOne, Bit B, Bit Going
    , Bit D) GDBW_Clr( Bit ClkG, Bit G, Bit W
    , Bit DoneIn, Bit AClr) ;  //_GUI 46,36
 Object ( Bit Out1, Bit Out2, Bit Out3) Junction:D
    ( Bit In0) ;  //_GUI 28,30
 Object Text;  //_GUI 32,59,I can find no differences in behavior.  Maybe 2 is passing B out faster from W?Arial,8,0,1
 Object ( Bit GoOne, Bit B, Bit Going
    , Bit D) GDBW_Clr_alt( Bit ClkG, Bit G, Bit W
    , Bit DoneIn, Bit AClr) ;  //_GUI 45,17

 // Behavior Topology
 Output = GDBW_Clr_alt.GoOne;  
 Output:A = GDBW_Clr_alt.B;  
 Output:B = GDBW_Clr_alt.Going;  
 Output:C = GDBW_Clr_alt.D;  
 Output:D = GDBW_Clr.GoOne;  
 Output:E = GDBW_Clr.B;  
 Output:F = GDBW_Clr.Going;  
 Output:G = GDBW_Clr.D;  
 Junction = Input:C;  
 Junction:A = Input:B;  
 Junction:B = Input:A;  
 Junction:C = Input;  
 GDBW_Clr.ClkG = Junction:C.Out3;  //_GUI 41,38
 GDBW_Clr.G = Junction:B.Out3;  //_GUI 38,41
 GDBW_Clr.W = Junction:A.Out3;  //_GUI 35,44
 GDBW_Clr.DoneIn = Junction.Out3;  //_GUI 32,47
 GDBW_Clr.AClr = Junction:D.Out3;  //_GUI 29,50
 Junction:D = Input:D;  
 GDBW_Clr_alt.ClkG = Junction:C.Out2;  
 GDBW_Clr_alt.G = Junction:B.Out2;  
 GDBW_Clr_alt.W = Junction:A.Out2;  
 GDBW_Clr_alt.DoneIn = Junction.Out2;  
 GDBW_Clr_alt.AClr = Junction:D.Out2;  
}

Object ( Variant Busy1, Variant Busy2, Bit Done) Test_Sync
    ( Bit ClkG, Bit Go1, Bit Go2, Bit Wait) 
//_Attributes TreeGroup=TestLib\Control
{
// Description:
// Sync object test
//
// Date:
// March 11, 2004
 //_ Object Prototypes
 Object ( Bit ClkG) Input;  //_GUI 50,13
 Object ( Bit Go1) Input:A;  //_GUI 50,20
 Object ( Bit Go2) Input:B;  //_GUI 50,23
 Object ( Bit Wait) Input:C;  //_GUI 96,40
 Object Output( Variant Busy1) ;  //_GUI 100,29
 Object Output:A( Variant Busy2) ;  //_GUI 100,32
 Object Output:B( Bit Done) ;  //_GUI 118,48
 Object ( Bit Done, Variant Busy) Sync( Bit ClkG
    , Variant Go, Bit Wait) ;  //_GUI 89,15
 Object ( List Out) ListOut( Variant In1, Variant In2) ;  //_GUI 68,18
 //_Attributes Primitive
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 86,28
 //_Attributes Primitive

 // Behavior Topology
 Output = ListIn.Out2;  
 Output:A = ListIn.Out1;  
 Output:B = Sync.Done;  //_GUI 118,21
 Sync.ClkG = Input;  //_GUI 88,18, 88,14
 Sync.Go = ListOut;  
 Sync.Wait = Input:C;  //_GUI 115,24, 115,41
 ListOut.In1 = Input:B;  //_GUI 68,24
 ListOut.In2 = Input:A;  //_GUI 68,21
 ListIn = Sync.Busy;  //_GUI 81,31, 81,24
}

Object ( Variant Whole, Variant Fractional) Split_Fixed( Fix32 A) 
//_Attributes TreeGroup=TestLib\Arithmetic
{
// Description:
// Splits apart fixed numbers into their Whole part and fractional parts.
//
// Date:
// March 10, 2004
 //_ Object Prototypes
 Object ( Fix32 A) Input;  //_GUI 19,39
 Object Output( Variant Whole) ;  //_GUI 91,38
 Object Output:A( Variant Fractional) ;  //_GUI 91,41
 Object ( Variant Out1) DynamicOut( Variant In1) ;  //_GUI 33,37
 Object ( Variant Out1, Variant Out2) ListIn( List In) ;  //_GUI 64,37
 //_Attributes Primitive
 Object ( List Out1) FixedIn( Fixed In) ;  //_GUI 51,37
 //_Attributes Primitive
 Object Text;  //_GUI 36,28,The Whole part is a 2's compliment number.

 // Behavior Topology
 Output = ListIn.Out2;  
 Output:A = ListIn.Out1;  
 DynamicOut = Input;  
 ListIn = FixedIn;  
 FixedIn = DynamicOut;  
}

Object ( Variant Out1, Bit Done, Bit Busy) sum_products
    ( Bit I, Bit Wait) 
//_Attributes TreeGroup=TestLib\Arithmetic
{
// Description:
// sum_products test sheet.
//
// Inputs:
// I:  go
//
// Outputs:
// Out1: data
//
// Date:
// March 9, 2004
 //_ Object Prototypes
 Object ( Bit I) Input;  //_GUI 12,41
 Object ( Bit Wait) Input:A;  //_GUI 189,57
 Object Output( Variant Out1) ;  //_GUI 208,36
 Object Output:A( Bit Done) ;  //_GUI 207,45
 Object Output:B( Bit Busy) ;  //_GUI 37,55
 Object ( Bit CO, Variant S, Bit ClkG
    , Bit Done, Variant Busy) Add( Variant A, Variant B
    , Variant Prec, Bit ClkG, Variant Go, Bit Wait) ;  //_GUI 171,32
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 198,36
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 63,33
 Object ( Bit Pulse) OneShot( Bit I, Bit ClkG) ;  //_GUI 20,40
 Object ( LSB016 Iterations) Input:B;  //_GUI 11,33
 //_Attributes Constant="*4"
 Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) Mul( Variant A, Variant B
    , Variant Prec, Variant Radix, Bit ClkG, Variant Go
    , Bit Wait) ;  //_GUI 72,29
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 158,23
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 148,33
 Object Text;  //_GUI 133,63,Answer should be 98 for 4
 Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) Mul:A( Variant A, Variant B
    , Variant Prec, Variant Radix, Bit ClkG, Variant Go
    , Bit Wait) ;  //_GUI 119,29
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 110,33
 Object ( Variant Iteration, Bit LastDone, Bit Done
    , Variant Busy) DoneForN_Down( Variant Iterations, Bit ClkG, Bit AClrG
    , Variant Go, Bit Wait) ;  //_GUI 37,32

 // Behavior Topology
 Output = Junction.Out2;  
 Output:A = Add.Done;  
 Output:B = DoneForN_Down.Busy;  //_GUI 31,56, 31,46
 Add.A = Cast;  //_GUI 171,26
 Add.B = Junction:B.Out2;  //_GUI 158,37, 158,34
 Add.Go = Mul:A.Done;  
 Add.Wait = Input:A;  //_GUI 207,49, 207,58
 Junction = Add.S;  
 Junction:A = DoneForN_Down.Iteration;  
 OneShot.I = Input;  
 Mul.A = Junction:A.Out1;  //_GUI 64,31
 Mul.B = Junction:A.Out2;  
 Mul.Go = DoneForN_Down.Done;  //_GUI 65,46, 65,43
 Mul.Wait = Mul:A.Busy;  
 Cast.Type = Junction:B.Out1;  //_GUI 149,25
 Cast.Data = Junction.Out1;  //_GUI 155,28, 155,17, 199,17
 Junction:B = Mul:A.P;  
 Mul:A.A = Junction:C.Out1;  //_GUI 111,31
 Mul:A.B = Junction:C.Out2;  
 Mul:A.ClkG = Mul.ClkG;  //_GUI 105,43, 105,37
 Mul:A.Go = Mul.Done;  
 Mul:A.Wait = Add.Busy;  
 Junction:C = Mul.P;  
 DoneForN_Down.Iterations = Input:B;  
 DoneForN_Down.Go = OneShot;  
 DoneForN_Down.Wait = Mul.Busy;  //_GUI 62,46, 62,49
}

Object ( Variant Q, Bit Done, Bit Busy) sum_products_radix
    ( Bit I, Bit Wait) 
//_Attributes TreeGroup=TestLib\Arithmetic
{
// Description:
// Sum of Products
//
// Date:
// March 10, 2004
 //_ Object Prototypes
 Object ( Bit I) Input;  //_GUI 2,40
 Object ( Bit Wait) Input:A;  //_GUI 218,62
 Object Output( Variant Q) ;  //_GUI 230,36
 Object Output:A( Bit Done) ;  //_GUI 230,42
 Object Output:B( Bit Busy) ;  //_GUI 37,55
 Object ( Bit CO, Variant S, Bit ClkG
    , Bit Done, Variant Busy) Add( Variant A, Variant B
    , Variant Prec, Bit ClkG, Variant Go, Bit Wait) ;  //_GUI 171,31
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction
    ( Variant In0) ;  //_GUI 198,36
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:A
    ( Variant In0) ;  //_GUI 63,32
 Object ( Bit Pulse) OneShot( Bit I, Bit ClkG) ;  //_GUI 18,39
 Object ( LSB016 Iterations) Input:B;  //_GUI 2,32
 //_Attributes Constant="*4"
 Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) Mul( Variant A, Variant B
    , Variant Prec, Variant Radix, Bit ClkG, Variant Go
    , Bit Wait) ;  //_GUI 72,28
 Object ( Variant Out1) Cast( Variant Type, Variant Data) ;  //_GUI 157,23
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:B
    ( Variant In0) ;  //_GUI 148,32
 Object Text;  //_GUI 133,63,Answer should be 98 for 4
 Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) Mul:A( Variant A, Variant B
    , Variant Prec, Variant Radix, Bit ClkG, Variant Go
    , Bit Wait) ;  //_GUI 118,28
 Object ( Variant Out1, Variant Out2, Variant Out3) Junction:C
    ( Variant In0) ;  //_GUI 110,32
 Object ( Variant Q, Bit ClkG, Variant Done
    , Variant Busy) Register( Variant D, Bit ClkG, Variant Go
    , Variant Wait) ;  //_GUI 208,35
 //_Attributes Documentation=$Bit
 Object ( Variant Iteration, Bit LastDone, Bit Done
    , Variant Busy) DoneForN_Down( Variant Iterations, Bit ClkG, Bit AClrG
    , Variant Go, Bit Wait) ;  //_GUI 37,31

 // Behavior Topology
 Output = Register.Q;  
 Output:A = Register.Done;  
 Output:B = DoneForN_Down.Busy;  //_GUI 33,56, 33,45
 Add.A = Cast;  //_GUI 171,30, 167,30
 Add.B = Junction:B.Out2;  //_GUI 158,36, 158,33
 Add.ClkG = Mul:A.ClkG;  //_GUI 155,42, 155,36
 Add.Go = Mul:A.Done;  
 Add.Wait = Register.Busy;  //_GUI 199,48, 199,46
 Junction = Add.S;  //_GUI 194,37, 194,36
 Junction:A = DoneForN_Down.Iteration;  
 OneShot.I = Input;  
 Mul.A = Junction:A.Out1;  //_GUI 64,30
 Mul.B = Junction:A.Out2;  
 Mul.Radix = Junction:A.Out3;  //_GUI 64,39
 Mul.Go = DoneForN_Down.Done;  //_GUI 68,45, 68,42
 Mul.Wait = Mul:A.Busy;  
 Cast.Type = Junction:B.Out1;  //_GUI 149,25
 Cast.Data = Junction.Out1;  //_GUI 151,28, 151,17, 199,17
 Junction:B = Mul:A.P;  
 Mul:A.A = Junction:C.Out1;  //_GUI 111,30
 Mul:A.B = Junction:C.Out2;  
 Mul:A.Radix = Junction:C.Out3;  //_GUI 111,39
 Mul:A.ClkG = Mul.ClkG;  //_GUI 91,42
 Mul:A.Go = Mul.Done;  
 Mul:A.Wait = Add.Busy;  
 Junction:C = Mul.P;  
 Register.D = Junction.Out2;  
 Register.ClkG = Add.ClkG;  //_GUI 199,40, 199,39
 Register.Go = Add.Done;  //_GUI 199,43, 199,45
 Register.Wait = Input:A;  //_GUI 226,46, 226,63
 DoneForN_Down.Iterations = Input:B;  
 DoneForN_Down.Go = OneShot;  
 DoneForN_Down.Wait = Mul.Busy;  //_GUI 65,45, 65,48
}

Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) test_add_gdbw_fixed( Fix32 A, Fix32 B
    , Bit ClkG, Bit Go, Bit Wait) 
//_Attributes TreeGroup=TestLib\Arithmetic
{
// Description:
// Test for both Fixed Data Sets and for GDBW on the Add object.
//
// See sheet for testing instructions.
//
// Date:
// March 11, 2004
 //_ Object Prototypes
 Object ( Fix32 A) Input;  //_GUI 79,56
 Object ( Fix32 B) Input:A;  //_GUI 79,59
 Object ( Bit ClkG) Input:B;  //_GUI 78,65
 Object ( Bit Go) Input:C;  //_GUI 78,67
 Object ( Bit Wait) Input:D;  //_GUI 155,79
 Object Output( Bit OFL) ;  //_GUI 169,56
 Object Output:A( Variant P) ;  //_GUI 209,59
 Object Output:B( Bit ClkG) ;  //_GUI 209,62
 Object Output:C( Bit Done) ;  //_GUI 209,68
 Object Output:D( Variant Busy) ;  //_GUI 139,80
 Object Text;  //_GUI 119,19,You should be able to put a Go in with valid data every time the busy is not high. You should never see a done out without valid data on P. You should be able to stall at any time by putting the wait signal high. Manually clock it.Arial,8,0,1
 Object ( Bit OFL, Variant Out1) StaticOut( Variant Type
    , Variant Data) ;  //_GUI 193,55
 Object ( Variant Out1) DynamicOut( Variant In1) ;  //_GUI 92,52
 Object ( Variant Out1) DynamicOut:A( Variant In1) ;  //_GUI 93,59
 Object ( Fix32 Out1, Fix32 Out2, Fix32 Out3) Junction
    ( Fix32 In0) ;  //_GUI 85,56
 Object ( Bit CO, Variant S, Bit ClkG
    , Bit Done, Variant Busy) Add( Variant A, Variant B
    , Variant Prec, Bit ClkG, Variant Go, Bit Wait) ;  //_GUI 139,55
 Object Text;  //_GUI 4,13,Test 1:1. Assign values to 'A' & 'B' inputs2. Raise 'Go' 3. Step 'ClkG'4. Drop 'Go'5. Reassign 'A' & 'B' values6. Repeat Steps 2 - 4.7. Continue to step 'ClkG' / Monitor output.Results:  The sum of the two value assignments (steps 1 & 5) should appear on consecutive clock cycles.Arial,9,0,1
 Object Text;  //_GUI 4,53,Test 2:1.  Assign values to 'A' & 'B' inputs2.  Raise 'Go'3.  Raise 'Wait' 4.  Step 'ClkG'5.  Drop 'Go'6.  Step 'ClkG'7.  Reassign 'A' & 'B' values8.  Repeat Steps 2, 3, 5.9.  Continue to step 'ClkG' (multiple times)10. Lower 'Wait'11. Step 'ClkG' / Monitor outputResults: Step nine should produce the sum of the values applied at step one .  Only after the final step (11) should the sum of step seven values appear.  Any differing order shows a failure in the stalling of the object.Arial,9,0,1

 // Behavior Topology
 Output = Add.CO;  
 Output:A = StaticOut.Out1;  
 Output:B = Add.ClkG;  
 Output:C = Add.Done;  
 Output:D = Add.Busy;  //_GUI 129,81, 129,72
 StaticOut.Type = Junction.Out1;  //_GUI 193,44, 86,44
 StaticOut.Data = Add.S;  
 DynamicOut = Junction.Out2;  //_GUI 89,55, 89,57
 DynamicOut:A = Input:A;  //_GUI 89,62, 89,60
 Junction = Input;  
 Add.A = DynamicOut;  //_GUI 123,57, 123,55
 Add.B = DynamicOut:A;  //_GUI 123,60, 123,62
 Add.ClkG = Input:B;  
 Add.Go = Input:C;  //_GUI 139,68
 Add.Wait = Input:D;  //_GUI 169,72, 169,80
}

Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) test_add_gdbw_float( Float A, Float B
    , Bit ClkG, Bit Go, Bit Wait) 
//_Attributes TreeGroup=TestLib\Arithmetic
{
// Description:
// Test for both Float Data Sets and for GDBW on the Add object.
//
// See sheet for testing instructions.
//
// Date:
// March 11, 2004
 //_ Object Prototypes
 Object ( Float A) Input;  //_GUI 52,53
 Object ( Float B) Input:A;  //_GUI 52,60
 Object ( Bit ClkG) Input:B;  //_GUI 52,64
 Object ( Bit Go) Input:C;  //_GUI 52,67
 Object ( Bit Wait) Input:D;  //_GUI 131,82
 Object Output( Bit OFL) ;  //_GUI 140,55
 Object Output:A( Variant P) ;  //_GUI 181,58
 Object Output:B( Bit ClkG) ;  //_GUI 181,61
 Object Output:C( Bit Done) ;  //_GUI 181,67
 Object Output:D( Variant Busy) ;  //_GUI 109,82
 Object Text;  //_GUI 95,22,It should be possible to put a Go in with valid data every time the busy is not high. A done out should never come without valid data on P. Stalling should be possible at any time by asserting Wait Manually clock it.Arial,8,0,1
 Object ( Bit OFL, Variant Out1) StaticOut( Variant Type
    , Variant Data) ;  //_GUI 166,54
 Object ( Variant Out1) DynamicOut( Variant In1) ;  //_GUI 66,51
 Object ( Variant Out1) DynamicOut:A( Variant In1) ;  //_GUI 66,58
 Object ( Float Out1, Float Out2, Float Out3) Junction
    ( Float In0) ;  //_GUI 58,53
 Object ( Bit CO, Variant S, Bit ClkG
    , Bit Done, Variant Busy) Add( Variant A, Variant B
    , Variant Prec, Bit ClkG, Variant Go, Bit Wait) ;  //_GUI 112,54
 Object Text;  //_GUI 3,7,Test 1:1. Assign values to 'A' & 'B' inputs2. Raise 'Go' 3. Step 'ClkG'4. Drop 'Go'5. Reassign 'A' & 'B' values6. Repeat Steps 2 - 4.7. Continue to step 'ClkG' / Monitor output.Results:  The sum of the two value assignments (steps 1 & 5) should appear on consecutive clock cycles.Arial,9,0,1
 Object Text;  //_GUI 3,47,Test 2:1.  Assign values to 'A' & 'B' inputs2.  Raise 'Go'3.  Raise 'Wait' 4.  Step 'ClkG'5.  Drop 'Go'6.  Step 'ClkG'7.  Reassign 'A' & 'B' values8.  Repeat Steps 2, 3, 5.9.  Continue to step 'ClkG' (multiple times)10. Lower 'Wait'11. Step 'ClkG' / Monitor outputResults: Step nine should produce the sum of the values applied at step one .  Only after the final step (11) should the sum of step seven values appear.  Any differing order shows a failure in the stalling of the object.Arial,9,0,1

 // Behavior Topology
 Output = Add.CO;  
 Output:A = StaticOut.Out1;  
 Output:B = Add.ClkG;  
 Output:C = Add.Done;  
 Output:D = Add.Busy;  //_GUI 94,83, 94,71
 StaticOut.Type = Junction.Out1;  //_GUI 166,43, 59,43
 StaticOut.Data = Add.S;  
 DynamicOut = Junction.Out2;  
 DynamicOut:A = Input:A;  
 Junction = Input;  
 Add.A = DynamicOut;  //_GUI 96,56, 96,54
 Add.B = DynamicOut:A;  //_GUI 96,59, 96,61
 Add.ClkG = Input:B;  
 Add.Go = Input:C;  
 Add.Wait = Input:D;  //_GUI 148,71, 148,83
}

Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) test_add_gdbw_lsb( LSB008 A, Bit ClkG
    , Bit Go, Bit Wait) 
//_Attributes TreeGroup=TestLib\Arithmetic
{
// Description:
// Test sheet for GDBW on the add object as well as for LSB Data Sets.
//
// See sheet for testing instructions
//
// Date:
// March 11, 2004
 //_ Object Prototypes
 Object ( LSB008 A) Input;  //_GUI 65,22
 Object ( Bit ClkG) Input:A;  //_GUI 65,31
 Object ( Bit Go) Input:B;  //_GUI 65,34
 Object ( Bit Wait) Input:C;  //_GUI 142,54
 Object Output( Bit OFL) ;  //_GUI 160,22
 Object Output:A( Variant P) ;  //_GUI 160,25
 Object Output:B( Bit ClkG) ;  //_GUI 160,28
 Object Output:C( Bit Done) ;  //_GUI 160,34
 Object Output:D( Variant Busy) ;  //_GUI 123,54
 Object Text;  //_GUI 101,3,You should be able to put a Go in with valid data every time the busy is not high. You should never see a done out without valid data on P. You should be able to stall at any time by putting the wait signal high. Manually clock it.Arial,8,0,1
 Object ( Bit CO, Variant S, Bit ClkG
    , Bit Done, Variant Busy) Add( Variant A, Variant B
    , Variant Prec, Bit ClkG, Variant Go, Bit Wait) ;  //_GUI 125,21
 Object ( LSB008 Out1, LSB008 Out2, LSB008 Out3) Junction
    ( LSB008 In0) ;  //_GUI 91,22
 Object Text;  //_GUI 2,9,Test 1:1. Assign value to 'A'' input2. Raise 'Go' 3. Step 'ClkG'4. Drop 'Go'5. Reassign 'A' 6. Repeat Steps 2 - 4.7. Continue to step 'ClkG' / Monitor output.Results:  The sum of the two value assignments (steps 1 & 5) should appear on consecutive clock cycles.Arial,9,0,1
 Object Text;  //_GUI 2,49,Test 2:1.  Assign values to 'A' input2.  Raise 'Go'3.  Raise 'Wait' 4.  Step 'ClkG'5.  Drop 'Go'6.  Step 'ClkG'7.  Reassign 'A' 8.  Repeat Steps 2, 3, 5.9.  Continue to step 'ClkG' (multiple times)10. Lower 'Wait'11. Step 'ClkG' / Monitor outputResults: Step nine should produce the sum of the values applied at step one .  Only after the final step (11) should the sum of step seven values appear.  Any differing order shows a failure in the stalling of the object.Arial,9,0,1

 // Behavior Topology
 Output = Add.CO;  
 Output:A = Add.S;  
 Output:B = Add.ClkG;  
 Output:C = Add.Done;  
 Output:D = Add.Busy;  //_GUI 106,55, 106,38
 Add.A = Junction.Out2;  
 Add.B = Junction.Out3;  //_GUI 92,26
 Add.ClkG = Input:A;  
 Add.Go = Input:B;  
 Add.Wait = Input:C;  //_GUI 162,38, 162,55
 Junction = Input;  
}

Object ( Variant Q, Variant R, Bit ClkG
    , Bit Done, Variant Busy) test_div_gdbw_fixed( Fix32 A, Fix32 B
    , Bit ClkG, Bit Go, Bit Wait) 
//_Attributes TreeGroup=TestLib\Arithmetic
{
// Description:
// Test sheet for GDBW on Div object as well as for Fixed Data Sets.
//
// Date:
// March 11, 2004
 //_ Object Prototypes
 Object ( Fix32 A) Input;  //_GUI 51,54
 Object ( Fix32 B) Input:A;  //_GUI 51,60
 Object ( Bit ClkG) Input:B;  //_GUI 51,66
 Object ( Bit Go) Input:C;  //_GUI 51,69
 Object ( Bit Wait) Input:D;  //_GUI 128,83
 Object Output( Variant Q) ;  //_GUI 201,50
 Object Output:A( Variant R) ;  //_GUI 175,60
 Object Output:B( Bit ClkG) ;  //_GUI 175,63
 Object Output:C( Bit Done) ;  //_GUI 175,69
 Object Output:D( Variant Busy) ;  //_GUI 109,83
 Object ( Bit OFL, Variant Out1) StaticOut( Variant Type
    , Variant Data) ;  //_GUI 165,56
 Object ( Variant Out1) DynamicOut( Variant In1) ;  //_GUI 65,52
 Object ( Variant Out1) DynamicOut:A( Variant In1) ;  //_GUI 65,60
 Object ( Fix32 Out1, Fix32 Out2, Fix32 Out3) Junction
    ( Fix32 In0) ;  //_GUI 57,54
 Object ( Variant Q, Variant R, Bit ClkG
    , Bit Done, Variant Busy) Div( Variant A, Variant B
    , Variant Prec, Bit ClkG, Variant Go, Bit Wait) ;  //_GUI 111,56
 Object ( Bit OFL, Variant Out1) StaticOut:A( Variant Type
    , Variant Data) ;  //_GUI 167,46
 Object Text;  //_GUI 93,26,You should be able to put a Go in with valid data every time the busy is not high. You should never see a done out without valid data on P. You should be able to stall at any time by putting the wait signal high. Manually clock it.Arial,8,0,1
 Object ( Fix32 Out1, Fix32 Out2, Fix32 Out3) Junction:A
    ( Fix32 In0) ;  //_GUI 154,47
 Object Text;  //_GUI 4,15,Test 1:1. Assign values to 'A' & 'B' inputs2. Raise 'Go' 3. Step 'ClkG'4. Drop 'Go'5. Reassign 'A' & 'B' values6. Repeat Steps 2 - 4.7. Continue to step 'ClkG' / Monitor output.Results:  The result of the two value assignments (steps 1 & 5) should appear on consecutive clock cycles.Arial,9,0,1
 Object Text;  //_GUI 4,55,Test 2:1.  Assign values to 'A' & 'B' inputs2.  Raise 'Go'3.  Raise 'Wait' 4.  Step 'ClkG'5.  Drop 'Go'6.  Step 'ClkG'7.  Reassign 'A' & 'B' values8.  Repeat Steps 2, 3, 5.9.  Continue to step 'ClkG' (multiple times)10. Lower 'Wait'11. Step 'ClkG' / Monitor outputResults: Step nine should produce the result of the values applied at step one .  Only after the final step (11) should the result of step seven values appear.  Any differing order shows a failure in the stalling of the object.Arial,9,0,1

 // Behavior Topology
 Output = StaticOut:A.Out1;  
 Output:A = StaticOut.Out1;  
 Output:B = Div.ClkG;  
 Output:C = Div.Done;  
 Output:D = Div.Busy;  //_GUI 98,84, 98,73
 StaticOut.Type = Junction:A.Out3;  //_GUI 155,58
 StaticOut.Data = Div.R;  
 DynamicOut = Junction.Out2;  
 DynamicOut:A = Input:A;  //_GUI 58,63, 58,61
 Junction = Input;  
 Div.A = DynamicOut;  //_GUI 95,58, 95,55
 Div.B = DynamicOut:A;  //_GUI 95,61, 95,63
 Div.ClkG = Input:B;  
 Div.Go = Input:C;  
 Div.Wait = Input:D;  //_GUI 142,73, 142,84
 StaticOut:A.Type = Junction:A.Out2;  
 StaticOut:A.Data = Div.Q;  //_GUI 136,51, 136,58
 Junction:A = Junction.Out1;  //_GUI 58,48
}

Object ( Variant Q, Variant R, Bit ClkG
    , Bit Done, Variant Busy) test_div_gdbw_float( Float A, Float B
    , Bit ClkG, Bit Go, Bit Wait) 
//_Attributes TreeGroup=TestLib\Arithmetic
{
// Description:
// Test sheet for GDBW on Div object as well as for Floating Data Sets.
//
// Date:
// March 11, 2004
 //_ Object Prototypes
 Object ( Float A) Input;  //_GUI 58,57
 Object ( Float B) Input:A;  //_GUI 58,60
 Object ( Bit ClkG) Input:B;  //_GUI 58,66
 Object ( Bit Go) Input:C;  //_GUI 58,69
 Object ( Bit Wait) Input:D;  //_GUI 136,91
 Object Output( Variant Q) ;  //_GUI 195,52
 Object Output:A( Variant R) ;  //_GUI 195,60
 Object Output:B( Bit ClkG) ;  //_GUI 195,63
 Object Output:C( Bit Done) ;  //_GUI 195,69
 Object Output:D( Variant Busy) ;  //_GUI 116,91
 Object ( Bit OFL, Variant Out1) StaticOut( Variant Type
    , Variant Data) ;  //_GUI 172,56
 Object ( Variant Out1) DynamicOut( Variant In1) ;  //_GUI 73,53
 Object ( Variant Out1) DynamicOut:A( Variant In1) ;  //_GUI 73,60
 Object ( Variant Q, Variant R, Bit ClkG
    , Bit Done, Variant Busy) Div( Variant A, Variant B
    , Variant Prec, Bit ClkG, Variant Go, Bit Wait) ;  //_GUI 118,56
 Object ( Bit OFL, Variant Out1) StaticOut:A( Variant Type
    , Variant Data) ;  //_GUI 172,48
 Object Text;  //_GUI 98,32,You should be able to put a Go in with valid data every time the busy is not high. You should never see a done out without valid data on P. You should be able to stall at any time by putting the wait signal high. Manually clock it.Arial,8,0,1
 Object Text;  //_GUI 3,14,Test 1:1. Assign values to 'A' & 'B' inputs2. Raise 'Go' 3. Step 'ClkG'4. Drop 'Go'5. Reassign 'A' & 'B' values6. Repeat Steps 2 - 4.7. Continue to step 'ClkG' / Monitor output.Results:  The result of the two value assignments (steps 1 & 5) should appear on consecutive clock cycles.Arial,9,0,1
 Object Text;  //_GUI 3,54,Test 2:1.  Assign values to 'A' & 'B' inputs2.  Raise 'Go'3.  Raise 'Wait' 4.  Step 'ClkG'5.  Drop 'Go'6.  Step 'ClkG'7.  Reassign 'A' & 'B' values8.  Repeat Steps 2, 3, 5.9.  Continue to step 'ClkG' (multiple times)10. Lower 'Wait'11. Step 'ClkG' / Monitor outputResults: Step nine should produce the result of the values applied at step one .  Only after the final step (11) should the result of step seven values appear.  Any differing order shows a failure in the stalling of the object.Arial,9,0,1
 Object ( Float Out1, Float Out2, Float Out3) Junction
    ( Float In0) ;  //_GUI 63,57
 Object ( Float Out1, Float Out2, Float Out3) Junction:A
    ( Float In0) ;  //_GUI 160,49

 // Behavior Topology
 Output = StaticOut:A.Out1;  
 Output:A = StaticOut.Out1;  
 Output:B = Div.ClkG;  
 Output:C = Div.Done;  
 Output:D = Div.Busy;  //_GUI 99,92, 99,73
 StaticOut.Type = Junction:A.Out3;  //_GUI 161,58
 StaticOut.Data = Div.R;  
 DynamicOut = Junction.Out2;  //_GUI 68,56, 68,58
 DynamicOut:A = Input:A;  //_GUI 68,63, 68,61
 Div.A = DynamicOut;  //_GUI 102,58, 102,56
 Div.B = DynamicOut:A;  //_GUI 102,61, 102,63
 Div.ClkG = Input:B;  
 Div.Go = Input:C;  
 Div.Wait = Input:D;  //_GUI 158,73, 158,92
 StaticOut:A.Type = Junction:A.Out2;  
 StaticOut:A.Data = Div.Q;  //_GUI 156,53, 156,58
 Junction = Input;  
 Junction:A = Junction.Out1;  //_GUI 64,50
}

Object ( Variant Q, Variant R, Bit ClkG
    , Bit Done, Variant Busy) test_div_gdbw_var( Variant A, Variant B
    , Bit ClkG, Bit Go, Bit Wait) 
//_Attributes TreeGroup=TestLib\Arithmetic
{
// Description:
// Test sheet for GDBW on Div object as well as for any Variant Type data set.
//
// Compile and run this sheet with multiptle Data Sets to ensure proper function.
//
// Date:
// March 11, 2004
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 64,47
 Object ( Variant B) Input:A;  //_GUI 64,50
 Object ( Bit ClkG) Input:B;  //_GUI 64,56
 Object ( Bit Go) Input:C;  //_GUI 64,59
 Object ( Bit Wait) Input:D;  //_GUI 108,73
 Object Output( Variant Q) ;  //_GUI 144,47
 Object Output:A( Variant R) ;  //_GUI 144,50
 Object Output:B( Bit ClkG) ;  //_GUI 144,53
 Object Output:C( Bit Done) ;  //_GUI 144,58
 Object Output:D( Variant Busy) ;  //_GUI 88,73
 Object Text;  //_GUI 78,26,You should be able to put a Go in with valid data every time the busy is not high. You should never see a done out without valid data on P. You should be able to stall at any time by putting the wait signal high. Manually clock it.Arial,8,0,1
 Object ( Variant Q, Variant R, Bit ClkG
    , Bit Done, Variant Busy) Div( Variant A, Variant B
    , Variant Prec, Bit ClkG, Variant Go, Bit Wait) ;  //_GUI 90,46
 Object Text;  //_GUI 3,18,Test 1:1. Assign values to 'A' & 'B' inputs2. Raise 'Go' 3. Step 'ClkG'4. Drop 'Go'5. Reassign 'A' & 'B' values6. Repeat Steps 2 - 4.7. Continue to step 'ClkG' / Monitor output.Results:  The result of the two value assignments (steps 1 & 5) should appear on consecutive clock cycles.Arial,9,0,1
 Object Text;  //_GUI 3,58,Test 2:1.  Assign values to 'A' & 'B' inputs2.  Raise 'Go'3.  Raise 'Wait' 4.  Step 'ClkG'5.  Drop 'Go'6.  Step 'ClkG'7.  Reassign 'A' & 'B' values8.  Repeat Steps 2, 3, 5.9.  Continue to step 'ClkG' (multiple times)10. Lower 'Wait'11. Step 'ClkG' / Monitor outputResults: Step nine should produce the result of the values applied at step one .  Only after the final step (11) should the result of step seven values appear.  Any differing order shows a failure in the stalling of the object.Arial,9,0,1

 // Behavior Topology
 Output = Div.Q;  
 Output:A = Div.R;  
 Output:B = Div.ClkG;  
 Output:C = Div.Done;  //_GUI 110,59, 110,60
 Output:D = Div.Busy;  //_GUI 72,74, 72,63
 Div.A = Input;  
 Div.B = Input:A;  
 Div.ClkG = Input:B;  
 Div.Go = Input:C;  
 Div.Wait = Input:D;  //_GUI 129,63, 129,74
}

Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) test_mul_gdbw_fixed( Fix32 A, Fix32 B
    , Bit ClkG, Bit Go, Bit Wait) 
//_Attributes TreeGroup=TestLib\Arithmetic
{
// Description:
// Test sheet for GDBW on Mul object as well as for Fixed Data Sets.
//
// Date:
// March 11, 2004
 //_ Object Prototypes
 Object ( Fix32 A) Input;  //_GUI 71,52
 Object ( Fix32 B) Input:A;  //_GUI 71,55
 Object ( Bit ClkG) Input:B;  //_GUI 72,64
 Object ( Bit Go) Input:C;  //_GUI 72,67
 Object ( Bit Wait) Input:D;  //_GUI 147,81
 Object Output( Bit OFL) ;  //_GUI 162,52
 Object Output:A( Variant P) ;  //_GUI 195,55
 Object Output:B( Bit ClkG) ;  //_GUI 195,58
 Object Output:C( Bit Done) ;  //_GUI 195,67
 Object Output:D( Variant Busy) ;  //_GUI 130,81
 Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) Mul( Variant A, Variant B
    , Variant Prec, Variant Radix, Bit ClkG, Variant Go
    , Bit Wait) ;  //_GUI 132,51
 Object Text;  //_GUI 114,19,You should be able to put a Go in with valid data every time the busy is not high. You should never see a done out without valid data on P. You should be able to stall at any time by putting the wait signal high. Manually clock it.Arial,8,0,1
 Object ( Bit OFL, Variant Out1) StaticOut( Variant Type
    , Variant Data) ;  //_GUI 185,51
 Object ( Variant Out1) DynamicOut( Variant In1) ;  //_GUI 85,47
 Object ( Variant Out1) DynamicOut:A( Variant In1) ;  //_GUI 85,56
 Object ( Fix32 Out1, Fix32 Out2, Fix32 Out3) Junction
    ( Fix32 In0) ;  //_GUI 77,52
 Object Text;  //_GUI 5,15,Test 1:1. Assign values to 'A' & 'B' inputs2. Raise 'Go' 3. Step 'ClkG'4. Drop 'Go'5. Reassign 'A' & 'B' values6. Repeat Steps 2 - 4.7. Continue to step 'ClkG' / Monitor output.Results:  The result of the two value assignments (steps 1 & 5) should appear on consecutive clock cycles.Arial,9,0,1
 Object Text;  //_GUI 5,55,Test 2:1.  Assign values to 'A' & 'B' inputs2.  Raise 'Go'3.  Raise 'Wait' 4.  Step 'ClkG'5.  Drop 'Go'6.  Step 'ClkG'7.  Reassign 'A' & 'B' values8.  Repeat Steps 2, 3, 5.9.  Continue to step 'ClkG' (multiple times)10. Lower 'Wait'11. Step 'ClkG' / Monitor outputResults: Step nine should produce the result of the values applied at step one .  Only after the final step (11) should the result of step seven values appear.  Any differing order shows a failure in the stalling of the object.Arial,9,0,1

 // Behavior Topology
 Output = Mul.OFL;  
 Output:A = StaticOut.Out1;  
 Output:B = Mul.ClkG;  
 Output:C = Mul.Done;  
 Output:D = Mul.Busy;  //_GUI 118,82, 118,71
 Mul.A = DynamicOut;  //_GUI 115,53, 115,50
 Mul.B = DynamicOut:A;  //_GUI 115,56, 115,59
 Mul.ClkG = Input:B;  
 Mul.Go = Input:C;  
 Mul.Wait = Input:D;  //_GUI 163,71, 163,82
 StaticOut.Type = Junction.Out1;  //_GUI 185,40, 78,40
 StaticOut.Data = Mul.P;  
 DynamicOut = Junction.Out2;  //_GUI 82,50, 82,53
 DynamicOut:A = Input:A;  //_GUI 82,59, 82,56
 Junction = Input;  
}

Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) test_mul_gdbw_float( Float A, Float B
    , Bit ClkG, Bit Go, Bit Wait) 
//_Attributes TreeGroup=TestLib\Arithmetic
{
// Description:
// SQRT GDBW for floats
//
// Date:
// March 10, 2004
 //_ Object Prototypes
 Object ( Float A) Input;  //_GUI 23,39
 Object ( Float B) Input:A;  //_GUI 23,42
 Object ( Bit ClkG) Input:B;  //_GUI 23,51
 Object ( Bit Go) Input:C;  //_GUI 23,54
 Object ( Bit Wait) Input:D;  //_GUI 107,72
 Object Output( Bit OFL) ;  //_GUI 103,39
 Object Output:A( Variant P) ;  //_GUI 151,42
 Object Output:B( Bit ClkG) ;  //_GUI 151,45
 Object Output:C( Bit Done) ;  //_GUI 151,54
 Object Output:D( Variant Busy) ;  //_GUI 66,72
 Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) Mul( Variant A, Variant B
    , Variant Prec, Variant Radix, Bit ClkG, Variant Go
    , Bit Wait) ;  //_GUI 84,38
 Object Text;  //_GUI 67,9,You should be able to put a Go in with valid data every time the busy is not high. You should never see a done out without valid data on P. You should be able to stall at any time by putting the wait signal high. Manually clock it.Arial,8,0,1
 Object ( Bit OFL, Variant Out1) StaticOut( Variant Type
    , Variant Data) ;  //_GUI 137,38
 Object ( Variant Out1) DynamicOut( Variant In1) ;  //_GUI 37,34
 Object ( Variant Out1) DynamicOut:A( Variant In1) ;  //_GUI 37,43
 Object ( Float Out1, Float Out2, Float Out3) Junction
    ( Float In0) ;  //_GUI 29,39

 // Behavior Topology
 Output = Mul.OFL;  
 Output:A = StaticOut.Out1;  
 Output:B = Mul.ClkG;  
 Output:C = Mul.Done;  
 Output:D = Mul.Busy;  //_GUI 61,73, 61,58
 Mul.A = DynamicOut;  //_GUI 67,40, 67,37
 Mul.B = DynamicOut:A;  //_GUI 67,43, 67,46
 Mul.ClkG = Input:B;  
 Mul.Go = Input:C;  
 Mul.Wait = Input:D;  //_GUI 121,58, 121,73
 StaticOut.Type = Junction.Out1;  //_GUI 133,40, 133,31, 30,31
 StaticOut.Data = Mul.P;  
 DynamicOut = Junction.Out2;  //_GUI 34,37, 34,40
 DynamicOut:A = Input:A;  //_GUI 34,46, 34,43
 Junction = Input;  
}

Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) test_mul_gdbw_var_bit( Variant A, Variant B
    , Bit ClkG, Bit Go, Bit Wait) 
//_Attributes TreeGroup=TestLib\Arithmetic
{
// Description:
// Test sheet for GDBW on Div object.
//
// Date:
// March 11, 2004
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 78,39
 Object ( Variant B) Input:A;  //_GUI 78,42
 Object ( Bit ClkG) Input:B;  //_GUI 79,51
 Object ( Bit Go) Input:C;  //_GUI 79,54
 Object ( Bit Wait) Input:D;  //_GUI 135,71
 Object Output( Bit OFL) ;  //_GUI 153,39
 Object Output:A( Variant P) ;  //_GUI 154,42
 Object Output:B( Bit ClkG) ;  //_GUI 154,45
 Object Output:C( Bit Done) ;  //_GUI 154,54
 Object Output:D( Variant Busy) ;  //_GUI 108,70
 Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) Mul( Variant A, Variant B
    , Variant Prec, Variant Radix, Bit ClkG, Variant Go
    , Bit Wait) ;  //_GUI 120,38
 Object Text;  //_GUI 94,23,You should be able to put a Go in with valid data every time the busy is not high. You should never see a done out without valid data on P. Use a MSB/LSB value for this test.Arial,8,0,1
 Object Text;  //_GUI 4,19,Test 1:1. Assign values to 'A' & 'B' inputs2. Raise 'Go' 3. Step 'ClkG'4. Drop 'Go'5. Reassign 'A' & 'B' values6. Repeat Steps 2 - 4.7. Continue to step 'ClkG' / Monitor output.Results:  The result of the two value assignments (steps 1 & 5) should appear on consecutive clock cycles.Arial,9,0,1
 Object Text;  //_GUI 4,59,Test 2:1.  Assign values to 'A' & 'B' inputs2.  Raise 'Go'3.  Raise 'Wait' 4.  Step 'ClkG'5.  Drop 'Go'6.  Step 'ClkG'7.  Reassign 'A' & 'B' values8.  Repeat Steps 2, 3, 5.9.  Continue to step 'ClkG' (multiple times)10. Lower 'Wait'11. Step 'ClkG' / Monitor outputResults: Step nine should produce the result of the values applied at step one .  Only after the final step (11) should the result of step seven values appear.  Any differing order shows a failure in the stalling of the object.Arial,9,0,1

 // Behavior Topology
 Output = Mul.OFL;  
 Output:A = Mul.P;  
 Output:B = Mul.ClkG;  
 Output:C = Mul.Done;  
 Output:D = Mul.Busy;  //_GUI 105,71, 105,58
 Mul.A = Input;  
 Mul.B = Input:A;  
 Mul.ClkG = Input:B;  
 Mul.Go = Input:C;  
 Mul.Wait = Input:D;  //_GUI 150,58, 150,72
}

Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) test_mul_gdbw_var_varrad( Variant A, Variant B
    , Variant Radix, Bit ClkG, Bit Go, Bit Wait) 
//_Attributes TreeGroup=TestLib\Arithmetic
{
// Description:
// Test sheet for GDBW on Mul object as well as for Variant Data Sets.
//
// Date:
// March 11, 2004
 //_ Object Prototypes
 Object ( Variant A) Input;  //_GUI 74,45
 Object ( Variant B) Input:A;  //_GUI 74,48
 Object ( Variant Radix) Input:B;  //_GUI 74,54
 Object ( Bit ClkG) Input:C;  //_GUI 74,57
 Object ( Bit Go) Input:D;  //_GUI 74,60
 Object ( Bit Wait) Input:E;  //_GUI 132,77
 Object Output( Bit OFL) ;  //_GUI 154,45
 Object Output:A( Variant P) ;  //_GUI 154,48
 Object Output:B( Bit ClkG) ;  //_GUI 154,51
 Object Output:C( Bit Done) ;  //_GUI 154,60
 Object Output:D( Variant Busy) ;  //_GUI 114,77
 Object ( Bit OFL, Variant P, Bit ClkG
    , Bit Done, Variant Busy) Mul( Variant A, Variant B
    , Variant Prec, Variant Radix, Bit ClkG, Variant Go
    , Bit Wait) ;  //_GUI 115,44
 Object Text;  //_GUI 90,25,You should be able to put a Go in with valid data every time the busy is not high. You should never see a done out without valid data on P. Use a MSB/LSB value for this test. You should be able to stall at any time by putting the wait signal high. Manually clock it.Arial,8,0,1

 // Behavior Topology
 Output = Mul.OFL;  
 Output:A = Mul.P;  
 Output:B = Mul.ClkG;  
 Output:C = Mul.Done;  
 Output:D = Mul.Busy;  //_GUI 100,78, 100,64
 Mul.A = Input;  
 Mul.B = Input:A;  
 Mul.Radix = Input:B;  
 Mul.ClkG = Input:C;  
 Mul.Go = Input:D;  
 Mul.Wait = Input:E;  //_GUI 151,64, 151,78
}

Object ( Variant P, Bit Done, Variant Busy) test_sqrt_gdbw_fixed
    ( Fix32 A, Bit ClkG, Bit Go, Bit Wait) 
//_Attributes TreeGroup=TestLib\Arithmetic
{
 //_ Object Prototypes
 Object ( Fix32 A) Input;  //_GUI 19,42
 Object ( Bit ClkG) Input:A;  //_GUI 19,48
 Object ( Bit Go) Input:B;  //_GUI 19,51
 Object ( Bit Wait) Input:C;  //_GUI 97,63
 Object Output( Variant P) ;  //_GUI 146,43
 Object Output:A( Bit Done) ;  //_GUI 146,51
 Object Output:B( Variant Busy) ;  //_GUI 77,63
 Object Text;  //_GUI 62,12,You should be able to put a Go in with valid data every time the busy is not high. You should never see a done out without valid data on P. You should be able to stall at any time by putting the wait signal high. Manually clock it.Arial,8,0,1
 Object ( Bit OFL, Variant Out1) StaticOut( Variant Type
    , Variant Data) ;  //_GUI 133,39
 Object ( Variant Out1) DynamicOut( Variant In1) ;  //_GUI 33,40
 Object ( Fix32 Out1, Fix32 Out2, Fix32 Out3) Junction
    ( Fix32 In0) ;  //_GUI 25,42
 Object ( Variant SQRT, Bit Done, Variant Busy) SQRT
    ( Variant Data, Variant Prec, Bit ClkG, Variant Go
    , Bit Wait) ;  //_GUI 79,41

 // Behavior Topology
 Output = StaticOut.Out1;  
 Output:A = SQRT.Done;  
 Output:B = SQRT.Busy;  //_GUI 67,64, 67,55
 StaticOut.Type = Junction.Out1;  //_GUI 133,30, 26,30
 StaticOut.Data = SQRT.SQRT;  
 DynamicOut = Junction.Out2;  
 Junction = Input;  
 SQRT.Data = DynamicOut;  
 SQRT.ClkG = Input:A;  
 SQRT.Go = Input:B;  
 SQRT.Wait = Input:C;  //_GUI 111,55, 111,64
}

Object ( Variant P, Bit Done, Variant Busy) test_sqrt_gdbw_float
    ( Float A, Bit ClkG, Bit Go, Bit Wait) 
//_Attributes TreeGroup=TestLib\Arithmetic
{
// Description:
// SQRT test for GDBW using float.
//
// Date:
// March 10, 2004
 //_ Object Prototypes
 Object ( Float A) Input;  //_GUI 7,38
 Object ( Bit ClkG) Input:A;  //_GUI 7,44
 Object ( Bit Go) Input:B;  //_GUI 7,47
 Object ( Bit Wait) Input:C;  //_GUI 84,66
 Object Output( Variant P) ;  //_GUI 138,39
 Object Output:A( Bit Done) ;  //_GUI 138,47
 Object Output:B( Variant Busy) ;  //_GUI 63,66
 Object Text;  //_GUI 50,8,You should be able to put a Go in with valid data every time the busy is not high. You should never see a done out without valid data on P. You should be able to stall at any time by putting the wait signal high. Manually clock it.Arial,8,0,1
 Object ( Bit OFL, Variant Out1) StaticOut( Variant Type
    , Variant Data) ;  //_GUI 121,35
 Object ( Variant Out1) DynamicOut( Variant In1) ;  //_GUI 21,36
 Object ( Float Out1, Float Out2, Float Out3) Junction
    ( Float In0) ;  //_GUI 15,38
 Object ( Variant SQRT, Bit Done, Variant Busy) SQRT
    ( Variant Data, Variant Prec, Bit ClkG, Variant Go
    , Bit Wait) ;  //_GUI 65,37

 // Behavior Topology
 Output = StaticOut.Out1;  
 Output:A = SQRT.Done;  
 Output:B = SQRT.Busy;  //_GUI 51,67, 51,51
 StaticOut.Type = Junction.Out1;  //_GUI 106,37, 106,33, 16,33
 StaticOut.Data = SQRT.SQRT;  
 DynamicOut = Junction.Out2;  
 Junction = Input;  
 SQRT.Data = DynamicOut;  
 SQRT.ClkG = Input:A;  
 SQRT.Go = Input:B;  
 SQRT.Wait = Input:C;  //_GUI 99,51, 99,67
}

Object ( Variant P, Bit Done, Variant Busy) test_sqrt_gdbw_var
    ( LSB008 A, Bit ClkG, Bit Go, Bit Wait) 
//_Attributes TreeGroup=TestLib\Arithmetic
{
// Description:
// the variant test for the GDBW on hte SQRT object.  A miminum of 10 clock cycles is required before output appears.  Continue stepping the clock until 'Done' goes high.  The output on 'P' should then be the desired value.
//
// Inputs:
// A:  data
//
// Outputs:
// P: SQRT(data)
// Done:  Done Pulse
//
// Date:
// March 10, 2004
 //_ Object Prototypes
 Object ( LSB008 A) Input;  //_GUI 51,25
 Object ( Bit ClkG) Input:A;  //_GUI 51,31
 Object ( Bit Go) Input:B;  //_GUI 51,34
 Object ( Bit Wait) Input:C;  //_GUI 90,51
 Object Output( Variant P) ;  //_GUI 106,26
 Object Output:A( Bit Done) ;  //_GUI 106,34
 Object Output:B( Variant Busy) ;  //_GUI 70,51
 Object Text;  //_GUI 180,25,You should be able to put a Go in with valid data every time the busy is not high. You should never see a done out without valid data on P. You should be able to stall at any time by putting the wait signal high. Manually clock it.
 Object ( Variant SQRT, Bit Done, Variant Busy) SQRT
    ( Variant Data, Variant Prec, Bit ClkG, Variant Go
    , Bit Wait) ;  //_GUI 68,24
 Object Text;  //_GUI 6,13,A minimum of 10 clock cycles is required before values appear at the output.

 // Behavior Topology
 Output = SQRT.SQRT;  
 Output:A = SQRT.Done;  
 Output:B = SQRT.Busy;  //_GUI 59,52, 59,38
 SQRT.Data = Input;  
 SQRT.ClkG = Input:A;  
 SQRT.Go = Input:B;  
 SQRT.Wait = Input:C;  //_GUI 102,38, 102,52
}

